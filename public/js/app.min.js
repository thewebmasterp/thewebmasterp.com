/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./content/js/actions/aboutPage.js":
/*!*****************************************!*\
  !*** ./content/js/actions/aboutPage.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const aboutPage = sp => {
  sp.log(`${sp.entryName} - ${sp.status}`)
  if (sp.DOMContentLoaded) {
    // Set the active navigation entry
    sp.setActiveNavEntr('aboutLink')

    // Give some custom structure to aboutme
    const me = document.getElementById('me')
    me.addEventListener('load', () => {
      const textAboutme = document.getElementById('text-aboutme')
      const figure = me.parentElement
      const figureHTML = figure.cloneNode(true).outerHTML
      figure.remove()
      textAboutme.innerHTML = `${figureHTML}<div>${textAboutme.innerHTML}</div>`
      document.getElementById('me').addEventListener('click', sp.openImageOn)
    })
  } else if (sp.load) {
  } else if (sp.beforeunload) {
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (aboutPage);


/***/ }),

/***/ "./content/js/actions/any.js":
/*!***********************************!*\
  !*** ./content/js/actions/any.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _components_themeChanger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/themeChanger */ "./content/js/components/themeChanger.js");
/* harmony import */ var _components_footerGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/footerGenerator */ "./content/js/components/footerGenerator.js");
/* harmony import */ var _components_socialMediaBoxGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/socialMediaBoxGenerator */ "./content/js/components/socialMediaBoxGenerator.js");
/* harmony import */ var _scripts_xml2json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../scripts/xml2json */ "./content/js/scripts/xml2json.js");






const any = sp => {
  sp.log(`${sp.entryName} - ${sp.status}`)

  // Initialize theme
  const attr = sp.config.themeAttribute
  let theme = localStorage.getItem(attr)
  if (!theme) {
    localStorage.setItem(attr, sp.config.defaultTheme)
    theme = sp.config.defaultTheme
  }
  document?.documentElement?.setAttribute?.(attr, theme)
  window?.REMARK42?.changeTheme?.(theme)
  setTimeout(() => {
    // Just to make sure
    window?.REMARK42?.changeTheme?.(theme)
  }, 1000)

  if (sp.DOMContentLoaded) {
    // Add a class of .preload to the body (and when the whole page is loaded - Remove it).
    document.body.classList.add('preload')

    // Apply the appropriate id to the current page's body
    const withIdOnly = sp.matchedRulesList.filter(entry => entry.id)
    if (!withIdOnly[0]) {
      sp.err('No matching rules for the current page!')
    }
    document.body.setAttribute('id', withIdOnly[0]?.id || 'undefined')

    // Every link pointing to an outside website should be opened in a new tab
    // Every link href should be formatted (I understand JS more than elisp... sry)
    const contentAnchors = document.getElementsByTagName('a')
    // NOTE: If you use any special characters like # or sth else in your filenames, list them here.
    const specChar = ['#']
    ;[...contentAnchors].forEach(a => {
      const href = a.getAttribute('href')
      if (href.startsWith('https://') || href.startsWith('http://')) {
        a.setAttribute('target', '_blank')
      } else if (
        href
          .substring(1)
          .split('')
          .some(str => specChar.includes(str)) ||
        decodeURIComponent(href.substring(1))
          .split('')
          .some(str => specChar.includes(str))
      ) {
        console.log(href)
        const newHref = encodeURIComponent(href)
        a.setAttribute('href', newHref)
      }
    })

    // Append a CSS class .clicked to a clicked anchor from #topnav
    const topNavLinks = sp.topnav.getElementsByTagName('a')
    ;[...topNavLinks].forEach(a => {
      a.addEventListener('click', e => {
        e.target.classList.add('clicked')
      })
    })

    // Theme changer controls
    const themSwrConstructionSites = [
      ...document.querySelectorAll('.theme-changer'),
    ]
    themSwrConstructionSites.forEach(site => {
      const btn = (0,_components_themeChanger__WEBPACK_IMPORTED_MODULE_0__["default"])('Toggle between dark and light mode', () => {
        //btn onclick callback
        const attr = sp.config.themeAttribute
        const currThemeFromAttr = document.documentElement.getAttribute(attr)
        const currThemeFromLStorage = localStorage.getItem(attr)
        if (currThemeFromAttr !== currThemeFromLStorage)
          console.warn('Theme attribute - Local storage dismatch!')
        const currentTheme = currThemeFromAttr
        if (currentTheme === 'light') {
          // Switch to dark
          localStorage.setItem(attr, 'dark')
          document.documentElement.setAttribute(attr, 'dark')
          window?.REMARK42?.changeTheme?.('dark')
        } else if (currentTheme === 'dark') {
          // Switch to light
          localStorage.setItem(attr, 'light')
          document.documentElement.setAttribute(attr, 'light')
          window?.REMARK42?.changeTheme?.('light')
        }
        if (site.parentNode.getAttribute('class') === 'sparse') {
          site.classList.add('top-level')
        }
      })
      if (site.parentNode.getAttribute('class') === 'sparse') {
        site.classList.add('top-level')
      }
      site.append(btn)
    })

    /*
    ;[...document.querySelectorAll('.theme-changer > button')].forEach(btn => {
      btn.addEventListener('click', () => {
        //Implement the local storage and DOM toggle
        sp.log('.theme-changer button clicked')
        const currentTheme = document.documentElement.getAttribute(attr)
        if (currentTheme === 'light') {
          // Switch to dark
          localStorage.setItem(attr, 'dark')
          document.documentElement.setAttribute(attr, 'dark')
          window?.REMARK42?.changeTheme?.('dark')
        } else if (currentTheme === 'dark') {
          // Switch to light
          localStorage.setItem(attr, 'light')
          document.documentElement.setAttribute(attr, 'light')
          window?.REMARK42?.changeTheme?.('light')
        } 

        // Add some cool styling to the button itself to indicate theme
      })
    })*/

    // Every image in #content, on click should be opened in a new tab.
    const imgs = sp.content?.getElementsByTagName('img')
    ;[...imgs].forEach(img => {
      img.addEventListener('click', sp.openImageOn)
    })
  } else if (sp.load) {
    // Remove the class of .preload of the body when the whole page's loaded.
    document.body.classList.remove('preload')

    // Remove the colon at the end of code line number
    ;[...document.getElementsByClassName('linenr')].forEach(line => {
      line.innerHTML = line.innerHTML.slice(0, -2).concat(' ')
    })

    //Make the footer
    const footer = (0,_components_footerGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(
      document.getElementById('postamble').getElementsByTagName('xml')[0]
    )
    //postamble.innerHTML += footer.outerHTML
    postamble.appendChild(footer)

    // Process .socMediaBox
    const socMediaBoxes = document.getElementsByClassName('socMediaBox')
    ;[...socMediaBoxes].forEach(socMediaBox => {
      const xml = socMediaBox.getElementsByTagName('xml')[0]
      if (xml) {
        const json = (0,_scripts_xml2json__WEBPACK_IMPORTED_MODULE_3__["default"])(xml)
        socMediaBox.innerHTML = (0,_components_socialMediaBoxGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(
          json['SOCMEDIA']['ENTRY'],
          sp.config.iconsBasePath
        ).outerHTML
      } else {
        console.error('missing xml in .socMediaBox!')
      }
    })
  } else if (sp.beforeunload) {
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (any);


/***/ }),

/***/ "./content/js/actions/blog.js":
/*!************************************!*\
  !*** ./content/js/actions/blog.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const blog = sp => {
  sp.log(`${sp.entryName} - ${sp.status}`)
  if (sp.DOMContentLoaded) {
    // Set the active navigation entry
    sp.setActiveNavEntr('blogLink')
  } else if (sp.load) {
  } else if (sp.beforeunload) {
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (blog);


/***/ }),

/***/ "./content/js/actions/blogArticle.js":
/*!*******************************************!*\
  !*** ./content/js/actions/blogArticle.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const blogArticle = sp => {
  sp.log(`${sp.entryName} - ${sp.status}`)
  if (sp.DOMContentLoaded) {
    // Get date passed through an html comment inside <head>
    const date = document.head.innerHTML
      .split('\n')[1]
      .replace(/<!-- | -->/g, '')

    // Get author and description from some <meta>s in <head>
    const author = document.querySelector('meta[name="author"]').content
    const description = document.querySelector('meta[name="description"]')
      .content

    // Structure the fetched metadata to be inserted on the right place
    const meta = ` <div id="ArticleMetaData">
Last change: ${date}<br>
Author: <a href="/about.html">${author}</a>
</div>`
    const descriptionHTML = `<p id="description">${description}</p>`

    // Insert the metadata
    const header = document
      .getElementById('content')
      .getElementsByTagName('header')[0]
    header.innerHTML = header.innerHTML + meta + descriptionHTML
  } else if (sp.load) {
  } else if (sp.beforeunload) {
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (blogArticle);


/***/ }),

/***/ "./content/js/actions/blogPage.js":
/*!****************************************!*\
  !*** ./content/js/actions/blogPage.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const blogPage = sp => {
  sp.log(`${sp.entryName} - ${sp.status}`)
  if (sp.DOMContentLoaded) {
    // Replace default section headings (arch/ js/ for example) with custom ones
    const mapTo = {
      'Desktop Setup/': {
        title: 'Optimizing your Linux desktop setup for programming',
        description:
          'Let the articles under this section be a compendium - An essence of my hard-learned lessons regarding Linux and its configuration as a maximum productivity, programming desktop OS.',
      },
      'webmaster_project/': {
        title: 'Master JavaScript',
        description:
          "Every JavaScript thing that got my interest and inspired me, I'll write a post about it and it will be listed here.",
      },
    }
    // Do it
    const entries = document.querySelectorAll('#entries > ul > li')
    entries.forEach(li => {
      const target = li.getElementsByTagName('b')[0]
      const inTarget = target.textContent
      Object.keys(mapTo).forEach(key => {
        if (inTarget === key) {
          const toReplaceTarget = document.createElement('div')
          const title = document.createElement('h3')
          title.textContent = mapTo[key].title
          const description = document.createElement('p')
          description.textContent = mapTo[key].description
          const descriptionWrapper = document.createElement('ul')
          descriptionWrapper.appendChild(description)
          toReplaceTarget.append(title, descriptionWrapper)
          target.parentNode.replaceChild(toReplaceTarget, target)
        }
      })
    })
  } else if (sp.load) {
  } else if (sp.beforeunload) {
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (blogPage);


/***/ }),

/***/ "./content/js/actions/contactPage.js":
/*!*******************************************!*\
  !*** ./content/js/actions/contactPage.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const contactPage = sp => {
  sp.log(`${sp.entryName} - ${sp.status}`)
  if (sp.DOMContentLoaded) {
    const contactme = document.getElementById('contactme')
    if (!contactme) console.error('No #contactme!')
    contactme.addEventListener('submit', () => {
      const subject = document.getElementById('subject')
      const action = contactme.getAttribute('action')
      const subjectPrefix = '?subject='
      const i = action.indexOf(subjectPrefix) + subjectPrefix.length
      contactme.setAttribute('action', action.slice(0, i) + subject.value)
      console.log(subject.value)
    })

    const greeting = 'Hey thewebmasterp, hear this joke. '
    const jokes = [
      "What are a shark's two most favorite words?", // Man overboard!
      'Why are ghosts such bad liars?', // Because they are easy to see through.
      'What do you call a singing laptop?', // A Dell!
      'What did the buffalo say when his son left for college?', // Bison!
      'Why did the web developer drown?', // He had too many anchors.
      'Why was the JavaScript reality show cancelled after only one episode?', // People thought it seemed scripted.
      'How can you tell that a web developer is working?', // You can hear him Grunting!
      'Why does no one like jokes about descriptions, keywords, or character encodings?', // They’re too ‘meta’.
      'Why did the IP cross the subnet?', // Because the NAT said to!
      'Why was the class upset that its parent died?', // Because it wouldn’t be getting the inheritance!
      'How do you comfort a JavaScript bug?', // You console it.
      'Why was the web developer fired from her job?', // She did Less every day.
      'How does a web developer like his coffee?', // #000000
      'Why did the web developer send a few extra bucks to her hosting provider?', // Because she heard that she should always tip her server.
      'Why couldn’t the programmer work late into the night?', // She didn’t have a LAMP.
    ].map(joke => `${greeting}${joke}`)

    const prop = 'alreadySeenJokes'
    let alreadySeen = JSON.parse(localStorage.getItem(prop)) || []
    if (alreadySeen.length === jokes.length) {
      // If all jokes seen, reset the tracker
      localStorage.setItem(prop, JSON.stringify([]))
      alreadySeen = JSON.parse(localStorage.getItem(prop))
    }
    // Remove the already seen jokes
    alreadySeen.forEach(n => {
      jokes.splice(n, 1)
    })
    const randomJokeIndex = Math.floor(Math.random() * jokes.length)
    const newAlreadySeen = JSON.parse(localStorage.getItem(prop)) || []
    newAlreadySeen.push(randomJokeIndex)
    localStorage.setItem(prop, JSON.stringify(newAlreadySeen))

    // Apply the chosen joke as a placeholder for the message
    document
      .getElementById('message')
      .setAttribute('placeholder', jokes[randomJokeIndex])
  } else if (sp.load) {
  } else if (sp.beforeunload) {
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (contactPage);


/***/ }),

/***/ "./content/js/actions/indexPage.js":
/*!*****************************************!*\
  !*** ./content/js/actions/indexPage.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const indexPage = sp => {
  sp.log(`${sp.entryName} - ${sp.status}`)

  // Welcome the user with a nice falling-from-the-sky message
  const welcomeUs = () => {
    const welcome = document.getElementById('welcome')
    const pgw = window.innerWidth
    welcome.style.bottom = pgw < 550 ? '5em' : '4em'
    welcome.style.opacity = '1'
    return welcomeUs //Returns itself (needed for addEventListener in this case)
  }

  // When the index page is reloaded, its scroll should always start from top. Else, there's a bug with the #mask.
  if ('scrollRestoration' in history) {
    history.scrollRestoration = 'manual'
  }

  if (sp.DOMContentLoaded) {
    // Set the active navigation entry
    sp.setActiveNavEntr('homeLink')

    // Parralax

    // Unite #preamble, #content and #postamble "under the flag" of #preConPosWrapper
    const preamble = document.getElementById('preamble').cloneNode(true)
    const content = document.getElementById('content').cloneNode(true)
    const postamble = document.getElementById('postamble').cloneNode(true)
    const preConPosWrapper = document.createElement('div')
    preConPosWrapper.setAttribute('id', 'preConPosWrapper')
    // Some insignificant boxes with gradient / fill.
    const boxes = new Array(4).fill('').map((box, i) => {
      box = document.createElement('div')
      box.className = 'fakeBg'
      box.id = `fakeBg-${i + 1}`
      const fills = new Array(2).fill('').map((fill, i) => {
        fill = document.createElement('div')
        fill.className = `fill-${i + 1}`
        return fill
      })
      box.append(...fills)
      return box
    })
    preConPosWrapper.append(preamble, content, postamble, ...boxes)

    let parallaxLayers = new Array(6).fill('').map(str => ({}))
    parallaxLayers.forEach((proto, i) => {
      proto.classList = []
      proto.classList.push('layer', `layer-${i}`)
    })
    parallaxLayers = parallaxLayers.map((proto, i, arr) => {
      const el = document.createElement('div')
      el.classList.add(...proto.classList)

      let content = ''
      if (i === arr.length - 1) {
        // If it is the last element add main content to it
        content = preConPosWrapper
      } else {
        // Else, it is a frame of the parallax
        // Create a sub-element which holds parallax frame background
        const img = document.createElement('div')
        img.classList.add('img')
        content = img
        /*
		 * Deprecated!
		 * Changing element class every few milliseconds triggers a DOM re-render
		 * which is causing this choppiness.
		 * 
        if (proto.toggleClasses?.length >= 2) {
          // Pick a random string from the arr and apply it to the .img in random intervals
          const randClassOnRandInterval = (
            el,
            arr,
            min = 200,
            max = 600,
            prev
          ) => {
            let randClass
            //Make sure the randClass is not the same as the old one.
            do {
              randClass = arr[Math.floor(Math.random() * arr.length)]
            } while (randClass === prev)

            const randInterval = Math.floor(
              Math.random() * (max - min + 1) + min
            )
            if (prev) {
              // Clean up
              el.classList.remove(prev)
            }
            el.classList.add(randClass)
            setTimeout(
              randClassOnRandInterval,
              randInterval,
              img,
              arr,
              min,
              max,
              randClass
            )
          }
          // All that needs multiple frames, set up individual settings here
          if (proto.toggleClasses.includes('hands1')) {
            // Toggle the hands
            randClassOnRandInterval(img, proto.toggleClasses, 150, 200)
          } else if (proto.toggleClasses.includes('eyes1')) {
            // Toggle the eyes
            randClassOnRandInterval(img, proto.toggleClasses, 50, 1000)
          }
        } */
      }
      el.append(content)

      return el
    })

    // Create the #parallax
    const parallax = document.createElement('div')
    parallax.setAttribute('id', 'parallax')
    parallax.append(...parallaxLayers)

    // Devastate and recreate the <body>
    document.body.innerHTML = ''
    document.body.appendChild(parallax)

    // 2. Greeting
    setTimeout(() => {
      window.addEventListener('resize', welcomeUs(), true) //Not a typo: Call welcomeUs initially and then on resize. (Notice that welcomeUs returns itself)
    }, 150)
  } else if (sp.load) {
  } else if (sp.beforeunload) {
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (indexPage);


/***/ }),

/***/ "./content/js/components/footerGenerator.js":
/*!**************************************************!*\
  !*** ./content/js/components/footerGenerator.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scripts_xml2json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scripts/xml2json */ "./content/js/scripts/xml2json.js");


const footerGenerator = xml => {
  const json = (0,_scripts_xml2json__WEBPACK_IMPORTED_MODULE_0__["default"])(xml)

  // SocialMedia
  const socmedia = document.createElement('div')
  socmedia.id = 'socmedia'
  const socialMediaBox = document.createElement('div')
  socialMediaBox.className = 'socMediaBox'
  socialMediaBox.innerHTML = `<xml>${
    xml.getElementsByTagName('socmedia')[0].outerHTML
  }</xml>` // The xml will later be replaced. Look at action any.js
  socmedia.append(socialMediaBox)

  // Subscribe (NOTE: For now this component is not needed, therefore it won't be displayed)
  /*
  const subscribe = document.createElement('div')
  subscribe.id = 'subscribe'
  const cta = document.createElement('h5')
  cta.id = 'cta'
  cta.innerHTML = json['SUBSCRIBE']['CTA']
  const subTwitter = document.createElement('div')
  subTwitter.id = 'subTwitter'
  const subEmail = document.createElement('div')
  subEmail.id = 'subEmail'
  const subRss = document.createElement('div')
  subRss.id = 'subRss'
  subscribe.append(cta, subTwitter, subEmail, subRss)
*/

  // Info
  const info = document.createElement('div')
  info.id = 'info'
  const div = document.createElement('div')
  div.innerHTML = `Built with Emacs Org-mode • <a href='https://github.com/thewebmasterp/thewebmasterp.com'>Code</a> open sourced • Read the <a href='privacy-policy.html'>Privacy Policy</a> • <a href="contact.html">Contact me</a>`
  info.appendChild(div)

  // Bottom
  const bottom = document.createElement('div')
  bottom.id = 'bottom'

  // Assemble and 'spit' the footer
  const footer = document.createElement('footer')
  footer.append(socmedia, /*subscribe*/ info, bottom)
  return footer
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (footerGenerator);


/***/ }),

/***/ "./content/js/components/socialMediaBoxGenerator.js":
/*!**********************************************************!*\
  !*** ./content/js/components/socialMediaBoxGenerator.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const socialMediaBoxGenerator = (arr, iconsBasePath) => {
  // input format: [{label: github, href: 'https://www.github.com', icon: './icons/icon.png' }, {...}]

  const box = document.createElement('div')
  box.className = 'socMediaBox'

  arr = arr.map(entry => {
    const profile = document.createElement('a')
    profile.className = 'profile'
    profile.href = entry['HREF']

    const icon = document.createElement('i')
    icon.title = entry['LABEL']

    const request = new XMLHttpRequest()
    request.open('GET', `${iconsBasePath}/${entry['ICON']}`, false) // `false` makes the request synchronous
    request.send(null)
    if (request.status === 200) {
      icon.innerHTML = request.responseText
    } else {
      console.error(`Error ${request.status} fetching icons.`)
    }

    profile.appendChild(icon)
    return profile
  })

  box.append(...arr)
  return box
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (socialMediaBoxGenerator);


/***/ }),

/***/ "./content/js/components/themeChanger.js":
/*!***********************************************!*\
  !*** ./content/js/components/themeChanger.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const iconGenerator = (label, innerHTML, tooltip) => {
  const icon = document.createElement('i')
  icon.classList.add(`${label}-icon`)
  icon.setAttribute('title', tooltip)
  icon.setAttribute('aria-hidden', true)
  // You can't properly generate svg element with document.createElement. You have to use createElementNS, as follows:
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
  // For more on the topic, see https://stackoverflow.com/questions/28734628/how-can-i-set-an-attribute-with-case-sensitive-name-in-a-javascript-generated-el/28734954
  svg.classList.add('feather', `feather-${label}`)
  svg.setAttribute('fill', 'none')
  svg.setAttribute('stroke', 'currentColor')
  svg.setAttribute('stroke-linecap', 'round')
  svg.setAttribute('stroke-linejoin', 'round')
  svg.setAttribute('stroke-width', '2')
  svg.setAttribute('viewBox', '0 0 24 24')
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
  svg.innerHTML = innerHTML
  icon.append(svg)

  return icon
}

const themeChangerBtn = (tooltip, onClick) => {
  //const constructionSites = [...document.querySelectorAll(selector)]

  const button = document.createElement('button')

  button.addEventListener('click', onClick)

  const moonInHTML =
    '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>'
  const sunInHTML =
    '<circle cx="12" cy="12" r="5"></circle><line x1="12" x2="12" y1="1" y2="3"></line><line x1="12" x2="12" y1="21" y2="23"></line><line x1="4.22" x2="5.64" y1="4.22" y2="5.64"></line><line x1="18.36" x2="19.78" y1="18.36" y2="19.78"></line><line x1="1" x2="3" y1="12" y2="12"></line><line x1="21" x2="23" y1="12" y2="12"></line><line x1="4.22" x2="5.64" y1="19.78" y2="18.36"></line><line x1="18.36" x2="19.78" y1="5.64" y2="4.22"></line>'
  const [moonIcon, sunIcon] = [
    iconGenerator('moon', moonInHTML, tooltip),
    iconGenerator('sun', sunInHTML, tooltip),
  ]

  const btnTextEl = document.createElement('span')
  btnTextEl.classList.add('sr-only')
  btnTextEl.textContent = tooltip

  button.append(moonIcon, sunIcon, btnTextEl)

  return button
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (themeChangerBtn);


/***/ }),

/***/ "./content/js/matomoInit.js":
/*!**********************************!*\
  !*** ./content/js/matomoInit.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const matomoInit = () => {
  // TODO: Enable and debug this script after pushed to production
  /*
  var _paq = (window._paq = window._paq || [])
  // tracker methods like "setCustomDimension" should be called before "trackPageView"
  _paq.push(['trackPageView'])
  _paq.push(['enableLinkTracking'])
  ;(function() {
	var u = '//matomo.thewebmasterp.com/'
	_paq.push(['setTrackerUrl', u + 'matomo.php'])
	_paq.push(['setSiteId', '1'])
	var d = document,
		g = d.createElement('script'),
		s = d.getElementsByTagName('script')[0]
	g.async = true
	g.src = u + 'matomo.js'
	s.parentNode.insertBefore(g, s)
  })()*/
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (matomoInit);


/***/ }),

/***/ "./content/js/scripts/xml2json.js":
/*!****************************************!*\
  !*** ./content/js/scripts/xml2json.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function xml2json(xml) {
  try {
    var obj = {}
    if (xml.children.length > 0) {
      for (var i = 0; i < xml.children.length; i++) {
        var item = xml.children.item(i)
        var nodeName = item.nodeName

        if (typeof obj[nodeName] == 'undefined') {
          obj[nodeName] = xml2json(item)
        } else {
          if (typeof obj[nodeName].push == 'undefined') {
            var old = obj[nodeName]

            obj[nodeName] = []
            obj[nodeName].push(old)
          }
          obj[nodeName].push(xml2json(item))
        }
      }
    } else {
      obj = xml.textContent
    }
    return obj
  } catch (e) {
    console.log(e.message)
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (xml2json);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl + "../";
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
(() => {
var __webpack_exports__ = {};
/*!*****************************!*\
  !*** ./content/js/index.js ***!
  \*****************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _matomoInit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matomoInit */ "./content/js/matomoInit.js");
/* harmony import */ var _actions_any__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./actions/any */ "./content/js/actions/any.js");
/* harmony import */ var _actions_indexPage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./actions/indexPage */ "./content/js/actions/indexPage.js");
/* harmony import */ var _actions_aboutPage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actions/aboutPage */ "./content/js/actions/aboutPage.js");
/* harmony import */ var _actions_contactPage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./actions/contactPage */ "./content/js/actions/contactPage.js");
/* harmony import */ var _actions_blog__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./actions/blog */ "./content/js/actions/blog.js");
/* harmony import */ var _actions_blogPage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./actions/blogPage */ "./content/js/actions/blogPage.js");
/* harmony import */ var _actions_blogArticle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./actions/blogArticle */ "./content/js/actions/blogArticle.js");










const CONFIG = {
  defaultTheme: 'dark',
  themeAttribute: 'data-theme',
  iconsBasePath: '/css/icons',
}

class Rule {
  constructor(name, condition, action, id) {
    this.name = name
    this.condition = condition
    this.action = action
    this.id = id
  }
  static genCondit(arr) {
    return path => {
      // NOTE: Sometimes, if the link has a doubleshlash, it fails these tests and the
      // site breaks! I didn't resolve this in the front-end because even if i did so,
      // it wouldn't solve the problem in its root: Why this whole thing depends on the url?
      return arr.some(str => {
        /*
        console.log(`Comparing: '${str}' with '${path}'`)
        console.log(
          `=> ${str === path} ||
            ${str === decodeURIComponent(path)} ||
            ${str === encodeURIComponent(path)}`
        )*/
        return (
          str === path ||
          str === decodeURIComponent(path) ||
          str === encodeURIComponent(path)
        )
      })
    }
  }
}

const rules = [
  new Rule('any', () => true, _actions_any__WEBPACK_IMPORTED_MODULE_1__["default"]),
  new Rule(
    'indexPage',
    Rule.genCondit(['/', '/index', '/index.html', 'index']),
    _actions_indexPage__WEBPACK_IMPORTED_MODULE_2__["default"],
    'index'
  ),
  new Rule(
    'aboutPage',
    Rule.genCondit(['/about.html', '/about', 'about']),
    _actions_aboutPage__WEBPACK_IMPORTED_MODULE_3__["default"],
    'about'
  ),
  new Rule(
    'contactPage',
    Rule.genCondit(['/contact.html', '/contact', 'contact']),
    _actions_contactPage__WEBPACK_IMPORTED_MODULE_4__["default"],
    'contact'
  ),
  new Rule('blog', path => path.includes('blog'), _actions_blog__WEBPACK_IMPORTED_MODULE_5__["default"]),
  new Rule(
    'blogPage',
    Rule.genCondit(['/blog.html', '/blog', 'blog']),
    _actions_blogPage__WEBPACK_IMPORTED_MODULE_6__["default"],
    'blog'
  ),
  new Rule(
    'article',
    path => {
      return (
        path.includes('blog') &&
        !Rule.genCondit(['/blog.html', '/blog', 'blog'])(path)
      )
    },
    _actions_blogArticle__WEBPACK_IMPORTED_MODULE_7__["default"],
    'article'
  ),
]

const main = (event, config) => {
  const status = event.type
  const pathname = window.location.pathname
  const matching = rules.filter(entry => {
    // console.log(entry.condition)
    return entry.condition(pathname)
  })
  const starterPack = {
    config: config,
    status: status,
    DOMContentLoaded: status === 'DOMContentLoaded',
    load: status === 'load',
    beforeunload: status === 'beforeunload',
    html: document.documentElement,
    head: document.head,
    body: document.body,
    preamble: document.getElementById('preamble'),
    topnav: document.getElementById('topnav'),
    content: document.getElementById('content'),
    postamble: document.getElementById('postamble'),
    footer: document.getElementsByTagName('footer')[0],
    log: console.log,
    err: console.error,
    matchedRulesList: matching,
    setActiveNavEntr: className => {
      const target = document.getElementsByClassName(className)[0]
      target.setAttribute('data-current', '')
    },
    openImageOn: event => {
      const url = event.target.getAttribute('src')
      window.open(url, '_blank').focus()
    },
  }
  matching.forEach(entry => {
    if (entry.name === 'any') return
    starterPack.entryName = entry.name || null
    entry.action(starterPack)
  })
  // 'any' should be called last
  matching.forEach(entry => {
    if (entry.name === 'any') {
      starterPack.entryName = 'any'
      entry.action(starterPack)
    }
  })

  // Initialize matomo
  ;(0,_matomoInit__WEBPACK_IMPORTED_MODULE_0__["default"])()
}

const mainCaller = event => {
  main(event, CONFIG)
}
window.addEventListener('DOMContentLoaded', mainCaller) // DOM loaded
window.addEventListener('load', mainCaller) // DOM + static loaded
window.addEventListener('beforeunload', mainCaller) // unloaded (pressing back, visiting link ...)

})();

// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
(() => {
/*!*********************************!*\
  !*** ./content/scss/style.scss ***!
  \*********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "css/style.min.css");
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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YWNrOi8vdGhld2VibWFzdGVycC5jb20vLi9jb250ZW50L2pzL2FjdGlvbnMvYWJvdXRQYWdlLmpzIiwid2VicGFjazovL3RoZXdlYm1hc3RlcnAuY29tLy4vY29udGVudC9qcy9hY3Rpb25zL2FueS5qcyIsIndlYnBhY2s6Ly90aGV3ZWJtYXN0ZXJwLmNvbS8uL2NvbnRlbnQvanMvYWN0aW9ucy9ibG9nLmpzIiwid2VicGFjazovL3RoZXdlYm1hc3RlcnAuY29tLy4vY29udGVudC9qcy9hY3Rpb25zL2Jsb2dBcnRpY2xlLmpzIiwid2VicGFjazovL3RoZXdlYm1hc3RlcnAuY29tLy4vY29udGVudC9qcy9hY3Rpb25zL2Jsb2dQYWdlLmpzIiwid2VicGFjazovL3RoZXdlYm1hc3RlcnAuY29tLy4vY29udGVudC9qcy9hY3Rpb25zL2NvbnRhY3RQYWdlLmpzIiwid2VicGFjazovL3RoZXdlYm1hc3RlcnAuY29tLy4vY29udGVudC9qcy9hY3Rpb25zL2luZGV4UGFnZS5qcyIsIndlYnBhY2s6Ly90aGV3ZWJtYXN0ZXJwLmNvbS8uL2NvbnRlbnQvanMvY29tcG9uZW50cy9mb290ZXJHZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vdGhld2VibWFzdGVycC5jb20vLi9jb250ZW50L2pzL2NvbXBvbmVudHMvc29jaWFsTWVkaWFCb3hHZW5lcmF0b3IuanMiLCJ3ZWJwYWNrOi8vdGhld2VibWFzdGVycC5jb20vLi9jb250ZW50L2pzL2NvbXBvbmVudHMvdGhlbWVDaGFuZ2VyLmpzIiwid2VicGFjazovL3RoZXdlYm1hc3RlcnAuY29tLy4vY29udGVudC9qcy9tYXRvbW9Jbml0LmpzIiwid2VicGFjazovL3RoZXdlYm1hc3RlcnAuY29tLy4vY29udGVudC9qcy9zY3JpcHRzL3htbDJqc29uLmpzIiwid2VicGFjazovL3RoZXdlYm1hc3RlcnAuY29tL3dlYnBhY2svYm9vdHN0cmFwIiwid2VicGFjazovL3RoZXdlYm1hc3RlcnAuY29tL3dlYnBhY2svcnVudGltZS9kZWZpbmUgcHJvcGVydHkgZ2V0dGVycyIsIndlYnBhY2s6Ly90aGV3ZWJtYXN0ZXJwLmNvbS93ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsIiwid2VicGFjazovL3RoZXdlYm1hc3RlcnAuY29tL3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vdGhld2VibWFzdGVycC5jb20vd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCIsIndlYnBhY2s6Ly90aGV3ZWJtYXN0ZXJwLmNvbS93ZWJwYWNrL3J1bnRpbWUvcHVibGljUGF0aCIsIndlYnBhY2s6Ly90aGV3ZWJtYXN0ZXJwLmNvbS8uL2NvbnRlbnQvanMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdGhld2VibWFzdGVycC5jb20vLi9jb250ZW50L3Njc3Mvc3R5bGUuc2NzcyJdLCJzb3VyY2VzQ29udGVudCI6WyJjb25zdCBhYm91dFBhZ2UgPSBzcCA9PiB7XG4gIHNwLmxvZyhgJHtzcC5lbnRyeU5hbWV9IC0gJHtzcC5zdGF0dXN9YClcbiAgaWYgKHNwLkRPTUNvbnRlbnRMb2FkZWQpIHtcbiAgICAvLyBTZXQgdGhlIGFjdGl2ZSBuYXZpZ2F0aW9uIGVudHJ5XG4gICAgc3Auc2V0QWN0aXZlTmF2RW50cignYWJvdXRMaW5rJylcblxuICAgIC8vIEdpdmUgc29tZSBjdXN0b20gc3RydWN0dXJlIHRvIGFib3V0bWVcbiAgICBjb25zdCBtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtZScpXG4gICAgbWUuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHRleHRBYm91dG1lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3RleHQtYWJvdXRtZScpXG4gICAgICBjb25zdCBmaWd1cmUgPSBtZS5wYXJlbnRFbGVtZW50XG4gICAgICBjb25zdCBmaWd1cmVIVE1MID0gZmlndXJlLmNsb25lTm9kZSh0cnVlKS5vdXRlckhUTUxcbiAgICAgIGZpZ3VyZS5yZW1vdmUoKVxuICAgICAgdGV4dEFib3V0bWUuaW5uZXJIVE1MID0gYCR7ZmlndXJlSFRNTH08ZGl2PiR7dGV4dEFib3V0bWUuaW5uZXJIVE1MfTwvZGl2PmBcbiAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtZScpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgc3Aub3BlbkltYWdlT24pXG4gICAgfSlcbiAgfSBlbHNlIGlmIChzcC5sb2FkKSB7XG4gIH0gZWxzZSBpZiAoc3AuYmVmb3JldW5sb2FkKSB7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYWJvdXRQYWdlXG4iLCJpbXBvcnQgdGhlbWVDaGFuZ2VyQnRuIGZyb20gJy4uL2NvbXBvbmVudHMvdGhlbWVDaGFuZ2VyJ1xuaW1wb3J0IGZvb3RlckdlbmVyYXRvciBmcm9tICcuLi9jb21wb25lbnRzL2Zvb3RlckdlbmVyYXRvcidcbmltcG9ydCBzb2NpYWxNZWRpYUJveEdlbmVyYXRvciBmcm9tICcuLi9jb21wb25lbnRzL3NvY2lhbE1lZGlhQm94R2VuZXJhdG9yJ1xuXG5pbXBvcnQgeG1sMmpzb24gZnJvbSAnLi4vc2NyaXB0cy94bWwyanNvbidcblxuY29uc3QgYW55ID0gc3AgPT4ge1xuICBzcC5sb2coYCR7c3AuZW50cnlOYW1lfSAtICR7c3Auc3RhdHVzfWApXG5cbiAgLy8gSW5pdGlhbGl6ZSB0aGVtZVxuICBjb25zdCBhdHRyID0gc3AuY29uZmlnLnRoZW1lQXR0cmlidXRlXG4gIGxldCB0aGVtZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKGF0dHIpXG4gIGlmICghdGhlbWUpIHtcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShhdHRyLCBzcC5jb25maWcuZGVmYXVsdFRoZW1lKVxuICAgIHRoZW1lID0gc3AuY29uZmlnLmRlZmF1bHRUaGVtZVxuICB9XG4gIGRvY3VtZW50Py5kb2N1bWVudEVsZW1lbnQ/LnNldEF0dHJpYnV0ZT8uKGF0dHIsIHRoZW1lKVxuICB3aW5kb3c/LlJFTUFSSzQyPy5jaGFuZ2VUaGVtZT8uKHRoZW1lKVxuICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAvLyBKdXN0IHRvIG1ha2Ugc3VyZVxuICAgIHdpbmRvdz8uUkVNQVJLNDI/LmNoYW5nZVRoZW1lPy4odGhlbWUpXG4gIH0sIDEwMDApXG5cbiAgaWYgKHNwLkRPTUNvbnRlbnRMb2FkZWQpIHtcbiAgICAvLyBBZGQgYSBjbGFzcyBvZiAucHJlbG9hZCB0byB0aGUgYm9keSAoYW5kIHdoZW4gdGhlIHdob2xlIHBhZ2UgaXMgbG9hZGVkIC0gUmVtb3ZlIGl0KS5cbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5hZGQoJ3ByZWxvYWQnKVxuXG4gICAgLy8gQXBwbHkgdGhlIGFwcHJvcHJpYXRlIGlkIHRvIHRoZSBjdXJyZW50IHBhZ2UncyBib2R5XG4gICAgY29uc3Qgd2l0aElkT25seSA9IHNwLm1hdGNoZWRSdWxlc0xpc3QuZmlsdGVyKGVudHJ5ID0+IGVudHJ5LmlkKVxuICAgIGlmICghd2l0aElkT25seVswXSkge1xuICAgICAgc3AuZXJyKCdObyBtYXRjaGluZyBydWxlcyBmb3IgdGhlIGN1cnJlbnQgcGFnZSEnKVxuICAgIH1cbiAgICBkb2N1bWVudC5ib2R5LnNldEF0dHJpYnV0ZSgnaWQnLCB3aXRoSWRPbmx5WzBdPy5pZCB8fCAndW5kZWZpbmVkJylcblxuICAgIC8vIEV2ZXJ5IGxpbmsgcG9pbnRpbmcgdG8gYW4gb3V0c2lkZSB3ZWJzaXRlIHNob3VsZCBiZSBvcGVuZWQgaW4gYSBuZXcgdGFiXG4gICAgLy8gRXZlcnkgbGluayBocmVmIHNob3VsZCBiZSBmb3JtYXR0ZWQgKEkgdW5kZXJzdGFuZCBKUyBtb3JlIHRoYW4gZWxpc3AuLi4gc3J5KVxuICAgIGNvbnN0IGNvbnRlbnRBbmNob3JzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2EnKVxuICAgIC8vIE5PVEU6IElmIHlvdSB1c2UgYW55IHNwZWNpYWwgY2hhcmFjdGVycyBsaWtlICMgb3Igc3RoIGVsc2UgaW4geW91ciBmaWxlbmFtZXMsIGxpc3QgdGhlbSBoZXJlLlxuICAgIGNvbnN0IHNwZWNDaGFyID0gWycjJ11cbiAgICA7Wy4uLmNvbnRlbnRBbmNob3JzXS5mb3JFYWNoKGEgPT4ge1xuICAgICAgY29uc3QgaHJlZiA9IGEuZ2V0QXR0cmlidXRlKCdocmVmJylcbiAgICAgIGlmIChocmVmLnN0YXJ0c1dpdGgoJ2h0dHBzOi8vJykgfHwgaHJlZi5zdGFydHNXaXRoKCdodHRwOi8vJykpIHtcbiAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ3RhcmdldCcsICdfYmxhbmsnKVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgaHJlZlxuICAgICAgICAgIC5zdWJzdHJpbmcoMSlcbiAgICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgICAgLnNvbWUoc3RyID0+IHNwZWNDaGFyLmluY2x1ZGVzKHN0cikpIHx8XG4gICAgICAgIGRlY29kZVVSSUNvbXBvbmVudChocmVmLnN1YnN0cmluZygxKSlcbiAgICAgICAgICAuc3BsaXQoJycpXG4gICAgICAgICAgLnNvbWUoc3RyID0+IHNwZWNDaGFyLmluY2x1ZGVzKHN0cikpXG4gICAgICApIHtcbiAgICAgICAgY29uc29sZS5sb2coaHJlZilcbiAgICAgICAgY29uc3QgbmV3SHJlZiA9IGVuY29kZVVSSUNvbXBvbmVudChocmVmKVxuICAgICAgICBhLnNldEF0dHJpYnV0ZSgnaHJlZicsIG5ld0hyZWYpXG4gICAgICB9XG4gICAgfSlcblxuICAgIC8vIEFwcGVuZCBhIENTUyBjbGFzcyAuY2xpY2tlZCB0byBhIGNsaWNrZWQgYW5jaG9yIGZyb20gI3RvcG5hdlxuICAgIGNvbnN0IHRvcE5hdkxpbmtzID0gc3AudG9wbmF2LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJylcbiAgICA7Wy4uLnRvcE5hdkxpbmtzXS5mb3JFYWNoKGEgPT4ge1xuICAgICAgYS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGUgPT4ge1xuICAgICAgICBlLnRhcmdldC5jbGFzc0xpc3QuYWRkKCdjbGlja2VkJylcbiAgICAgIH0pXG4gICAgfSlcblxuICAgIC8vIFRoZW1lIGNoYW5nZXIgY29udHJvbHNcbiAgICBjb25zdCB0aGVtU3dyQ29uc3RydWN0aW9uU2l0ZXMgPSBbXG4gICAgICAuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudGhlbWUtY2hhbmdlcicpLFxuICAgIF1cbiAgICB0aGVtU3dyQ29uc3RydWN0aW9uU2l0ZXMuZm9yRWFjaChzaXRlID0+IHtcbiAgICAgIGNvbnN0IGJ0biA9IHRoZW1lQ2hhbmdlckJ0bignVG9nZ2xlIGJldHdlZW4gZGFyayBhbmQgbGlnaHQgbW9kZScsICgpID0+IHtcbiAgICAgICAgLy9idG4gb25jbGljayBjYWxsYmFja1xuICAgICAgICBjb25zdCBhdHRyID0gc3AuY29uZmlnLnRoZW1lQXR0cmlidXRlXG4gICAgICAgIGNvbnN0IGN1cnJUaGVtZUZyb21BdHRyID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyKVxuICAgICAgICBjb25zdCBjdXJyVGhlbWVGcm9tTFN0b3JhZ2UgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShhdHRyKVxuICAgICAgICBpZiAoY3VyclRoZW1lRnJvbUF0dHIgIT09IGN1cnJUaGVtZUZyb21MU3RvcmFnZSlcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1RoZW1lIGF0dHJpYnV0ZSAtIExvY2FsIHN0b3JhZ2UgZGlzbWF0Y2ghJylcbiAgICAgICAgY29uc3QgY3VycmVudFRoZW1lID0gY3VyclRoZW1lRnJvbUF0dHJcbiAgICAgICAgaWYgKGN1cnJlbnRUaGVtZSA9PT0gJ2xpZ2h0Jykge1xuICAgICAgICAgIC8vIFN3aXRjaCB0byBkYXJrXG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYXR0ciwgJ2RhcmsnKVxuICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0ciwgJ2RhcmsnKVxuICAgICAgICAgIHdpbmRvdz8uUkVNQVJLNDI/LmNoYW5nZVRoZW1lPy4oJ2RhcmsnKVxuICAgICAgICB9IGVsc2UgaWYgKGN1cnJlbnRUaGVtZSA9PT0gJ2RhcmsnKSB7XG4gICAgICAgICAgLy8gU3dpdGNoIHRvIGxpZ2h0XG4gICAgICAgICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYXR0ciwgJ2xpZ2h0JylcbiAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHIsICdsaWdodCcpXG4gICAgICAgICAgd2luZG93Py5SRU1BUks0Mj8uY2hhbmdlVGhlbWU/LignbGlnaHQnKVxuICAgICAgICB9XG4gICAgICAgIGlmIChzaXRlLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpID09PSAnc3BhcnNlJykge1xuICAgICAgICAgIHNpdGUuY2xhc3NMaXN0LmFkZCgndG9wLWxldmVsJylcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICAgIGlmIChzaXRlLnBhcmVudE5vZGUuZ2V0QXR0cmlidXRlKCdjbGFzcycpID09PSAnc3BhcnNlJykge1xuICAgICAgICBzaXRlLmNsYXNzTGlzdC5hZGQoJ3RvcC1sZXZlbCcpXG4gICAgICB9XG4gICAgICBzaXRlLmFwcGVuZChidG4pXG4gICAgfSlcblxuICAgIC8qXG4gICAgO1suLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcudGhlbWUtY2hhbmdlciA+IGJ1dHRvbicpXS5mb3JFYWNoKGJ0biA9PiB7XG4gICAgICBidG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgIC8vSW1wbGVtZW50IHRoZSBsb2NhbCBzdG9yYWdlIGFuZCBET00gdG9nZ2xlXG4gICAgICAgIHNwLmxvZygnLnRoZW1lLWNoYW5nZXIgYnV0dG9uIGNsaWNrZWQnKVxuICAgICAgICBjb25zdCBjdXJyZW50VGhlbWUgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHIpXG4gICAgICAgIGlmIChjdXJyZW50VGhlbWUgPT09ICdsaWdodCcpIHtcbiAgICAgICAgICAvLyBTd2l0Y2ggdG8gZGFya1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGF0dHIsICdkYXJrJylcbiAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHIsICdkYXJrJylcbiAgICAgICAgICB3aW5kb3c/LlJFTUFSSzQyPy5jaGFuZ2VUaGVtZT8uKCdkYXJrJylcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VGhlbWUgPT09ICdkYXJrJykge1xuICAgICAgICAgIC8vIFN3aXRjaCB0byBsaWdodFxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGF0dHIsICdsaWdodCcpXG4gICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyLCAnbGlnaHQnKVxuICAgICAgICAgIHdpbmRvdz8uUkVNQVJLNDI/LmNoYW5nZVRoZW1lPy4oJ2xpZ2h0JylcbiAgICAgICAgfSBcblxuICAgICAgICAvLyBBZGQgc29tZSBjb29sIHN0eWxpbmcgdG8gdGhlIGJ1dHRvbiBpdHNlbGYgdG8gaW5kaWNhdGUgdGhlbWVcbiAgICAgIH0pXG4gICAgfSkqL1xuXG4gICAgLy8gRXZlcnkgaW1hZ2UgaW4gI2NvbnRlbnQsIG9uIGNsaWNrIHNob3VsZCBiZSBvcGVuZWQgaW4gYSBuZXcgdGFiLlxuICAgIGNvbnN0IGltZ3MgPSBzcC5jb250ZW50Py5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaW1nJylcbiAgICA7Wy4uLmltZ3NdLmZvckVhY2goaW1nID0+IHtcbiAgICAgIGltZy5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNwLm9wZW5JbWFnZU9uKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAoc3AubG9hZCkge1xuICAgIC8vIFJlbW92ZSB0aGUgY2xhc3Mgb2YgLnByZWxvYWQgb2YgdGhlIGJvZHkgd2hlbiB0aGUgd2hvbGUgcGFnZSdzIGxvYWRlZC5cbiAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ3ByZWxvYWQnKVxuXG4gICAgLy8gUmVtb3ZlIHRoZSBjb2xvbiBhdCB0aGUgZW5kIG9mIGNvZGUgbGluZSBudW1iZXJcbiAgICA7Wy4uLmRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ2xpbmVucicpXS5mb3JFYWNoKGxpbmUgPT4ge1xuICAgICAgbGluZS5pbm5lckhUTUwgPSBsaW5lLmlubmVySFRNTC5zbGljZSgwLCAtMikuY29uY2F0KCcgJylcbiAgICB9KVxuXG4gICAgLy9NYWtlIHRoZSBmb290ZXJcbiAgICBjb25zdCBmb290ZXIgPSBmb290ZXJHZW5lcmF0b3IoXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncG9zdGFtYmxlJykuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3htbCcpWzBdXG4gICAgKVxuICAgIC8vcG9zdGFtYmxlLmlubmVySFRNTCArPSBmb290ZXIub3V0ZXJIVE1MXG4gICAgcG9zdGFtYmxlLmFwcGVuZENoaWxkKGZvb3RlcilcblxuICAgIC8vIFByb2Nlc3MgLnNvY01lZGlhQm94XG4gICAgY29uc3Qgc29jTWVkaWFCb3hlcyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoJ3NvY01lZGlhQm94JylcbiAgICA7Wy4uLnNvY01lZGlhQm94ZXNdLmZvckVhY2goc29jTWVkaWFCb3ggPT4ge1xuICAgICAgY29uc3QgeG1sID0gc29jTWVkaWFCb3guZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3htbCcpWzBdXG4gICAgICBpZiAoeG1sKSB7XG4gICAgICAgIGNvbnN0IGpzb24gPSB4bWwyanNvbih4bWwpXG4gICAgICAgIHNvY01lZGlhQm94LmlubmVySFRNTCA9IHNvY2lhbE1lZGlhQm94R2VuZXJhdG9yKFxuICAgICAgICAgIGpzb25bJ1NPQ01FRElBJ11bJ0VOVFJZJ10sXG4gICAgICAgICAgc3AuY29uZmlnLmljb25zQmFzZVBhdGhcbiAgICAgICAgKS5vdXRlckhUTUxcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ21pc3NpbmcgeG1sIGluIC5zb2NNZWRpYUJveCEnKVxuICAgICAgfVxuICAgIH0pXG4gIH0gZWxzZSBpZiAoc3AuYmVmb3JldW5sb2FkKSB7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYW55XG4iLCJjb25zdCBibG9nID0gc3AgPT4ge1xuICBzcC5sb2coYCR7c3AuZW50cnlOYW1lfSAtICR7c3Auc3RhdHVzfWApXG4gIGlmIChzcC5ET01Db250ZW50TG9hZGVkKSB7XG4gICAgLy8gU2V0IHRoZSBhY3RpdmUgbmF2aWdhdGlvbiBlbnRyeVxuICAgIHNwLnNldEFjdGl2ZU5hdkVudHIoJ2Jsb2dMaW5rJylcbiAgfSBlbHNlIGlmIChzcC5sb2FkKSB7XG4gIH0gZWxzZSBpZiAoc3AuYmVmb3JldW5sb2FkKSB7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgYmxvZ1xuIiwiY29uc3QgYmxvZ0FydGljbGUgPSBzcCA9PiB7XG4gIHNwLmxvZyhgJHtzcC5lbnRyeU5hbWV9IC0gJHtzcC5zdGF0dXN9YClcbiAgaWYgKHNwLkRPTUNvbnRlbnRMb2FkZWQpIHtcbiAgICAvLyBHZXQgZGF0ZSBwYXNzZWQgdGhyb3VnaCBhbiBodG1sIGNvbW1lbnQgaW5zaWRlIDxoZWFkPlxuICAgIGNvbnN0IGRhdGUgPSBkb2N1bWVudC5oZWFkLmlubmVySFRNTFxuICAgICAgLnNwbGl0KCdcXG4nKVsxXVxuICAgICAgLnJlcGxhY2UoLzwhLS0gfCAtLT4vZywgJycpXG5cbiAgICAvLyBHZXQgYXV0aG9yIGFuZCBkZXNjcmlwdGlvbiBmcm9tIHNvbWUgPG1ldGE+cyBpbiA8aGVhZD5cbiAgICBjb25zdCBhdXRob3IgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJhdXRob3JcIl0nKS5jb250ZW50XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCdtZXRhW25hbWU9XCJkZXNjcmlwdGlvblwiXScpXG4gICAgICAuY29udGVudFxuXG4gICAgLy8gU3RydWN0dXJlIHRoZSBmZXRjaGVkIG1ldGFkYXRhIHRvIGJlIGluc2VydGVkIG9uIHRoZSByaWdodCBwbGFjZVxuICAgIGNvbnN0IG1ldGEgPSBgIDxkaXYgaWQ9XCJBcnRpY2xlTWV0YURhdGFcIj5cbkxhc3QgY2hhbmdlOiAke2RhdGV9PGJyPlxuQXV0aG9yOiA8YSBocmVmPVwiL2Fib3V0Lmh0bWxcIj4ke2F1dGhvcn08L2E+XG48L2Rpdj5gXG4gICAgY29uc3QgZGVzY3JpcHRpb25IVE1MID0gYDxwIGlkPVwiZGVzY3JpcHRpb25cIj4ke2Rlc2NyaXB0aW9ufTwvcD5gXG5cbiAgICAvLyBJbnNlcnQgdGhlIG1ldGFkYXRhXG4gICAgY29uc3QgaGVhZGVyID0gZG9jdW1lbnRcbiAgICAgIC5nZXRFbGVtZW50QnlJZCgnY29udGVudCcpXG4gICAgICAuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWRlcicpWzBdXG4gICAgaGVhZGVyLmlubmVySFRNTCA9IGhlYWRlci5pbm5lckhUTUwgKyBtZXRhICsgZGVzY3JpcHRpb25IVE1MXG4gIH0gZWxzZSBpZiAoc3AubG9hZCkge1xuICB9IGVsc2UgaWYgKHNwLmJlZm9yZXVubG9hZCkge1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJsb2dBcnRpY2xlXG4iLCJjb25zdCBibG9nUGFnZSA9IHNwID0+IHtcbiAgc3AubG9nKGAke3NwLmVudHJ5TmFtZX0gLSAke3NwLnN0YXR1c31gKVxuICBpZiAoc3AuRE9NQ29udGVudExvYWRlZCkge1xuICAgIC8vIFJlcGxhY2UgZGVmYXVsdCBzZWN0aW9uIGhlYWRpbmdzIChhcmNoLyBqcy8gZm9yIGV4YW1wbGUpIHdpdGggY3VzdG9tIG9uZXNcbiAgICBjb25zdCBtYXBUbyA9IHtcbiAgICAgICdEZXNrdG9wIFNldHVwLyc6IHtcbiAgICAgICAgdGl0bGU6ICdPcHRpbWl6aW5nIHlvdXIgTGludXggZGVza3RvcCBzZXR1cCBmb3IgcHJvZ3JhbW1pbmcnLFxuICAgICAgICBkZXNjcmlwdGlvbjpcbiAgICAgICAgICAnTGV0IHRoZSBhcnRpY2xlcyB1bmRlciB0aGlzIHNlY3Rpb24gYmUgYSBjb21wZW5kaXVtIC0gQW4gZXNzZW5jZSBvZiBteSBoYXJkLWxlYXJuZWQgbGVzc29ucyByZWdhcmRpbmcgTGludXggYW5kIGl0cyBjb25maWd1cmF0aW9uIGFzIGEgbWF4aW11bSBwcm9kdWN0aXZpdHksIHByb2dyYW1taW5nIGRlc2t0b3AgT1MuJyxcbiAgICAgIH0sXG4gICAgICAnd2VibWFzdGVyX3Byb2plY3QvJzoge1xuICAgICAgICB0aXRsZTogJ01hc3RlciBKYXZhU2NyaXB0JyxcbiAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgXCJFdmVyeSBKYXZhU2NyaXB0IHRoaW5nIHRoYXQgZ290IG15IGludGVyZXN0IGFuZCBpbnNwaXJlZCBtZSwgSSdsbCB3cml0ZSBhIHBvc3QgYWJvdXQgaXQgYW5kIGl0IHdpbGwgYmUgbGlzdGVkIGhlcmUuXCIsXG4gICAgICB9LFxuICAgIH1cbiAgICAvLyBEbyBpdFxuICAgIGNvbnN0IGVudHJpZXMgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcjZW50cmllcyA+IHVsID4gbGknKVxuICAgIGVudHJpZXMuZm9yRWFjaChsaSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBsaS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYicpWzBdXG4gICAgICBjb25zdCBpblRhcmdldCA9IHRhcmdldC50ZXh0Q29udGVudFxuICAgICAgT2JqZWN0LmtleXMobWFwVG8pLmZvckVhY2goa2V5ID0+IHtcbiAgICAgICAgaWYgKGluVGFyZ2V0ID09PSBrZXkpIHtcbiAgICAgICAgICBjb25zdCB0b1JlcGxhY2VUYXJnZXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnaDMnKVxuICAgICAgICAgIHRpdGxlLnRleHRDb250ZW50ID0gbWFwVG9ba2V5XS50aXRsZVxuICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgncCcpXG4gICAgICAgICAgZGVzY3JpcHRpb24udGV4dENvbnRlbnQgPSBtYXBUb1trZXldLmRlc2NyaXB0aW9uXG4gICAgICAgICAgY29uc3QgZGVzY3JpcHRpb25XcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKVxuICAgICAgICAgIGRlc2NyaXB0aW9uV3JhcHBlci5hcHBlbmRDaGlsZChkZXNjcmlwdGlvbilcbiAgICAgICAgICB0b1JlcGxhY2VUYXJnZXQuYXBwZW5kKHRpdGxlLCBkZXNjcmlwdGlvbldyYXBwZXIpXG4gICAgICAgICAgdGFyZ2V0LnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRvUmVwbGFjZVRhcmdldCwgdGFyZ2V0KVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIH0pXG4gIH0gZWxzZSBpZiAoc3AubG9hZCkge1xuICB9IGVsc2UgaWYgKHNwLmJlZm9yZXVubG9hZCkge1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJsb2dQYWdlXG4iLCJjb25zdCBjb250YWN0UGFnZSA9IHNwID0+IHtcbiAgc3AubG9nKGAke3NwLmVudHJ5TmFtZX0gLSAke3NwLnN0YXR1c31gKVxuICBpZiAoc3AuRE9NQ29udGVudExvYWRlZCkge1xuICAgIGNvbnN0IGNvbnRhY3RtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjb250YWN0bWUnKVxuICAgIGlmICghY29udGFjdG1lKSBjb25zb2xlLmVycm9yKCdObyAjY29udGFjdG1lIScpXG4gICAgY29udGFjdG1lLmFkZEV2ZW50TGlzdGVuZXIoJ3N1Ym1pdCcsICgpID0+IHtcbiAgICAgIGNvbnN0IHN1YmplY3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnc3ViamVjdCcpXG4gICAgICBjb25zdCBhY3Rpb24gPSBjb250YWN0bWUuZ2V0QXR0cmlidXRlKCdhY3Rpb24nKVxuICAgICAgY29uc3Qgc3ViamVjdFByZWZpeCA9ICc/c3ViamVjdD0nXG4gICAgICBjb25zdCBpID0gYWN0aW9uLmluZGV4T2Yoc3ViamVjdFByZWZpeCkgKyBzdWJqZWN0UHJlZml4Lmxlbmd0aFxuICAgICAgY29udGFjdG1lLnNldEF0dHJpYnV0ZSgnYWN0aW9uJywgYWN0aW9uLnNsaWNlKDAsIGkpICsgc3ViamVjdC52YWx1ZSlcbiAgICAgIGNvbnNvbGUubG9nKHN1YmplY3QudmFsdWUpXG4gICAgfSlcblxuICAgIGNvbnN0IGdyZWV0aW5nID0gJ0hleSB0aGV3ZWJtYXN0ZXJwLCBoZWFyIHRoaXMgam9rZS4gJ1xuICAgIGNvbnN0IGpva2VzID0gW1xuICAgICAgXCJXaGF0IGFyZSBhIHNoYXJrJ3MgdHdvIG1vc3QgZmF2b3JpdGUgd29yZHM/XCIsIC8vIE1hbiBvdmVyYm9hcmQhXG4gICAgICAnV2h5IGFyZSBnaG9zdHMgc3VjaCBiYWQgbGlhcnM/JywgLy8gQmVjYXVzZSB0aGV5IGFyZSBlYXN5IHRvIHNlZSB0aHJvdWdoLlxuICAgICAgJ1doYXQgZG8geW91IGNhbGwgYSBzaW5naW5nIGxhcHRvcD8nLCAvLyBBIERlbGwhXG4gICAgICAnV2hhdCBkaWQgdGhlIGJ1ZmZhbG8gc2F5IHdoZW4gaGlzIHNvbiBsZWZ0IGZvciBjb2xsZWdlPycsIC8vIEJpc29uIVxuICAgICAgJ1doeSBkaWQgdGhlIHdlYiBkZXZlbG9wZXIgZHJvd24/JywgLy8gSGUgaGFkIHRvbyBtYW55IGFuY2hvcnMuXG4gICAgICAnV2h5IHdhcyB0aGUgSmF2YVNjcmlwdCByZWFsaXR5IHNob3cgY2FuY2VsbGVkIGFmdGVyIG9ubHkgb25lIGVwaXNvZGU/JywgLy8gUGVvcGxlIHRob3VnaHQgaXQgc2VlbWVkIHNjcmlwdGVkLlxuICAgICAgJ0hvdyBjYW4geW91IHRlbGwgdGhhdCBhIHdlYiBkZXZlbG9wZXIgaXMgd29ya2luZz8nLCAvLyBZb3UgY2FuIGhlYXIgaGltIEdydW50aW5nIVxuICAgICAgJ1doeSBkb2VzIG5vIG9uZSBsaWtlIGpva2VzIGFib3V0IGRlc2NyaXB0aW9ucywga2V5d29yZHMsIG9yIGNoYXJhY3RlciBlbmNvZGluZ3M/JywgLy8gVGhleeKAmXJlIHRvbyDigJhtZXRh4oCZLlxuICAgICAgJ1doeSBkaWQgdGhlIElQIGNyb3NzIHRoZSBzdWJuZXQ/JywgLy8gQmVjYXVzZSB0aGUgTkFUIHNhaWQgdG8hXG4gICAgICAnV2h5IHdhcyB0aGUgY2xhc3MgdXBzZXQgdGhhdCBpdHMgcGFyZW50IGRpZWQ/JywgLy8gQmVjYXVzZSBpdCB3b3VsZG7igJl0IGJlIGdldHRpbmcgdGhlIGluaGVyaXRhbmNlIVxuICAgICAgJ0hvdyBkbyB5b3UgY29tZm9ydCBhIEphdmFTY3JpcHQgYnVnPycsIC8vIFlvdSBjb25zb2xlIGl0LlxuICAgICAgJ1doeSB3YXMgdGhlIHdlYiBkZXZlbG9wZXIgZmlyZWQgZnJvbSBoZXIgam9iPycsIC8vIFNoZSBkaWQgTGVzcyBldmVyeSBkYXkuXG4gICAgICAnSG93IGRvZXMgYSB3ZWIgZGV2ZWxvcGVyIGxpa2UgaGlzIGNvZmZlZT8nLCAvLyAjMDAwMDAwXG4gICAgICAnV2h5IGRpZCB0aGUgd2ViIGRldmVsb3BlciBzZW5kIGEgZmV3IGV4dHJhIGJ1Y2tzIHRvIGhlciBob3N0aW5nIHByb3ZpZGVyPycsIC8vIEJlY2F1c2Ugc2hlIGhlYXJkIHRoYXQgc2hlIHNob3VsZCBhbHdheXMgdGlwIGhlciBzZXJ2ZXIuXG4gICAgICAnV2h5IGNvdWxkbuKAmXQgdGhlIHByb2dyYW1tZXIgd29yayBsYXRlIGludG8gdGhlIG5pZ2h0PycsIC8vIFNoZSBkaWRu4oCZdCBoYXZlIGEgTEFNUC5cbiAgICBdLm1hcChqb2tlID0+IGAke2dyZWV0aW5nfSR7am9rZX1gKVxuXG4gICAgY29uc3QgcHJvcCA9ICdhbHJlYWR5U2Vlbkpva2VzJ1xuICAgIGxldCBhbHJlYWR5U2VlbiA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0ocHJvcCkpIHx8IFtdXG4gICAgaWYgKGFscmVhZHlTZWVuLmxlbmd0aCA9PT0gam9rZXMubGVuZ3RoKSB7XG4gICAgICAvLyBJZiBhbGwgam9rZXMgc2VlbiwgcmVzZXQgdGhlIHRyYWNrZXJcbiAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHByb3AsIEpTT04uc3RyaW5naWZ5KFtdKSlcbiAgICAgIGFscmVhZHlTZWVuID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShwcm9wKSlcbiAgICB9XG4gICAgLy8gUmVtb3ZlIHRoZSBhbHJlYWR5IHNlZW4gam9rZXNcbiAgICBhbHJlYWR5U2Vlbi5mb3JFYWNoKG4gPT4ge1xuICAgICAgam9rZXMuc3BsaWNlKG4sIDEpXG4gICAgfSlcbiAgICBjb25zdCByYW5kb21Kb2tlSW5kZXggPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBqb2tlcy5sZW5ndGgpXG4gICAgY29uc3QgbmV3QWxyZWFkeVNlZW4gPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKHByb3ApKSB8fCBbXVxuICAgIG5ld0FscmVhZHlTZWVuLnB1c2gocmFuZG9tSm9rZUluZGV4KVxuICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKHByb3AsIEpTT04uc3RyaW5naWZ5KG5ld0FscmVhZHlTZWVuKSlcblxuICAgIC8vIEFwcGx5IHRoZSBjaG9zZW4gam9rZSBhcyBhIHBsYWNlaG9sZGVyIGZvciB0aGUgbWVzc2FnZVxuICAgIGRvY3VtZW50XG4gICAgICAuZ2V0RWxlbWVudEJ5SWQoJ21lc3NhZ2UnKVxuICAgICAgLnNldEF0dHJpYnV0ZSgncGxhY2Vob2xkZXInLCBqb2tlc1tyYW5kb21Kb2tlSW5kZXhdKVxuICB9IGVsc2UgaWYgKHNwLmxvYWQpIHtcbiAgfSBlbHNlIGlmIChzcC5iZWZvcmV1bmxvYWQpIHtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBjb250YWN0UGFnZVxuIiwiY29uc3QgaW5kZXhQYWdlID0gc3AgPT4ge1xuICBzcC5sb2coYCR7c3AuZW50cnlOYW1lfSAtICR7c3Auc3RhdHVzfWApXG5cbiAgLy8gV2VsY29tZSB0aGUgdXNlciB3aXRoIGEgbmljZSBmYWxsaW5nLWZyb20tdGhlLXNreSBtZXNzYWdlXG4gIGNvbnN0IHdlbGNvbWVVcyA9ICgpID0+IHtcbiAgICBjb25zdCB3ZWxjb21lID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3dlbGNvbWUnKVxuICAgIGNvbnN0IHBndyA9IHdpbmRvdy5pbm5lcldpZHRoXG4gICAgd2VsY29tZS5zdHlsZS5ib3R0b20gPSBwZ3cgPCA1NTAgPyAnNWVtJyA6ICc0ZW0nXG4gICAgd2VsY29tZS5zdHlsZS5vcGFjaXR5ID0gJzEnXG4gICAgcmV0dXJuIHdlbGNvbWVVcyAvL1JldHVybnMgaXRzZWxmIChuZWVkZWQgZm9yIGFkZEV2ZW50TGlzdGVuZXIgaW4gdGhpcyBjYXNlKVxuICB9XG5cbiAgLy8gV2hlbiB0aGUgaW5kZXggcGFnZSBpcyByZWxvYWRlZCwgaXRzIHNjcm9sbCBzaG91bGQgYWx3YXlzIHN0YXJ0IGZyb20gdG9wLiBFbHNlLCB0aGVyZSdzIGEgYnVnIHdpdGggdGhlICNtYXNrLlxuICBpZiAoJ3Njcm9sbFJlc3RvcmF0aW9uJyBpbiBoaXN0b3J5KSB7XG4gICAgaGlzdG9yeS5zY3JvbGxSZXN0b3JhdGlvbiA9ICdtYW51YWwnXG4gIH1cblxuICBpZiAoc3AuRE9NQ29udGVudExvYWRlZCkge1xuICAgIC8vIFNldCB0aGUgYWN0aXZlIG5hdmlnYXRpb24gZW50cnlcbiAgICBzcC5zZXRBY3RpdmVOYXZFbnRyKCdob21lTGluaycpXG5cbiAgICAvLyBQYXJyYWxheFxuXG4gICAgLy8gVW5pdGUgI3ByZWFtYmxlLCAjY29udGVudCBhbmQgI3Bvc3RhbWJsZSBcInVuZGVyIHRoZSBmbGFnXCIgb2YgI3ByZUNvblBvc1dyYXBwZXJcbiAgICBjb25zdCBwcmVhbWJsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwcmVhbWJsZScpLmNsb25lTm9kZSh0cnVlKVxuICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGVudCcpLmNsb25lTm9kZSh0cnVlKVxuICAgIGNvbnN0IHBvc3RhbWJsZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwb3N0YW1ibGUnKS5jbG9uZU5vZGUodHJ1ZSlcbiAgICBjb25zdCBwcmVDb25Qb3NXcmFwcGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBwcmVDb25Qb3NXcmFwcGVyLnNldEF0dHJpYnV0ZSgnaWQnLCAncHJlQ29uUG9zV3JhcHBlcicpXG4gICAgLy8gU29tZSBpbnNpZ25pZmljYW50IGJveGVzIHdpdGggZ3JhZGllbnQgLyBmaWxsLlxuICAgIGNvbnN0IGJveGVzID0gbmV3IEFycmF5KDQpLmZpbGwoJycpLm1hcCgoYm94LCBpKSA9PiB7XG4gICAgICBib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgYm94LmNsYXNzTmFtZSA9ICdmYWtlQmcnXG4gICAgICBib3guaWQgPSBgZmFrZUJnLSR7aSArIDF9YFxuICAgICAgY29uc3QgZmlsbHMgPSBuZXcgQXJyYXkoMikuZmlsbCgnJykubWFwKChmaWxsLCBpKSA9PiB7XG4gICAgICAgIGZpbGwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICBmaWxsLmNsYXNzTmFtZSA9IGBmaWxsLSR7aSArIDF9YFxuICAgICAgICByZXR1cm4gZmlsbFxuICAgICAgfSlcbiAgICAgIGJveC5hcHBlbmQoLi4uZmlsbHMpXG4gICAgICByZXR1cm4gYm94XG4gICAgfSlcbiAgICBwcmVDb25Qb3NXcmFwcGVyLmFwcGVuZChwcmVhbWJsZSwgY29udGVudCwgcG9zdGFtYmxlLCAuLi5ib3hlcylcblxuICAgIGxldCBwYXJhbGxheExheWVycyA9IG5ldyBBcnJheSg2KS5maWxsKCcnKS5tYXAoc3RyID0+ICh7fSkpXG4gICAgcGFyYWxsYXhMYXllcnMuZm9yRWFjaCgocHJvdG8sIGkpID0+IHtcbiAgICAgIHByb3RvLmNsYXNzTGlzdCA9IFtdXG4gICAgICBwcm90by5jbGFzc0xpc3QucHVzaCgnbGF5ZXInLCBgbGF5ZXItJHtpfWApXG4gICAgfSlcbiAgICBwYXJhbGxheExheWVycyA9IHBhcmFsbGF4TGF5ZXJzLm1hcCgocHJvdG8sIGksIGFycikgPT4ge1xuICAgICAgY29uc3QgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgZWwuY2xhc3NMaXN0LmFkZCguLi5wcm90by5jbGFzc0xpc3QpXG5cbiAgICAgIGxldCBjb250ZW50ID0gJydcbiAgICAgIGlmIChpID09PSBhcnIubGVuZ3RoIC0gMSkge1xuICAgICAgICAvLyBJZiBpdCBpcyB0aGUgbGFzdCBlbGVtZW50IGFkZCBtYWluIGNvbnRlbnQgdG8gaXRcbiAgICAgICAgY29udGVudCA9IHByZUNvblBvc1dyYXBwZXJcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEVsc2UsIGl0IGlzIGEgZnJhbWUgb2YgdGhlIHBhcmFsbGF4XG4gICAgICAgIC8vIENyZWF0ZSBhIHN1Yi1lbGVtZW50IHdoaWNoIGhvbGRzIHBhcmFsbGF4IGZyYW1lIGJhY2tncm91bmRcbiAgICAgICAgY29uc3QgaW1nID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgaW1nLmNsYXNzTGlzdC5hZGQoJ2ltZycpXG4gICAgICAgIGNvbnRlbnQgPSBpbWdcbiAgICAgICAgLypcblx0XHQgKiBEZXByZWNhdGVkIVxuXHRcdCAqIENoYW5naW5nIGVsZW1lbnQgY2xhc3MgZXZlcnkgZmV3IG1pbGxpc2Vjb25kcyB0cmlnZ2VycyBhIERPTSByZS1yZW5kZXJcblx0XHQgKiB3aGljaCBpcyBjYXVzaW5nIHRoaXMgY2hvcHBpbmVzcy5cblx0XHQgKiBcbiAgICAgICAgaWYgKHByb3RvLnRvZ2dsZUNsYXNzZXM/Lmxlbmd0aCA+PSAyKSB7XG4gICAgICAgICAgLy8gUGljayBhIHJhbmRvbSBzdHJpbmcgZnJvbSB0aGUgYXJyIGFuZCBhcHBseSBpdCB0byB0aGUgLmltZyBpbiByYW5kb20gaW50ZXJ2YWxzXG4gICAgICAgICAgY29uc3QgcmFuZENsYXNzT25SYW5kSW50ZXJ2YWwgPSAoXG4gICAgICAgICAgICBlbCxcbiAgICAgICAgICAgIGFycixcbiAgICAgICAgICAgIG1pbiA9IDIwMCxcbiAgICAgICAgICAgIG1heCA9IDYwMCxcbiAgICAgICAgICAgIHByZXZcbiAgICAgICAgICApID0+IHtcbiAgICAgICAgICAgIGxldCByYW5kQ2xhc3NcbiAgICAgICAgICAgIC8vTWFrZSBzdXJlIHRoZSByYW5kQ2xhc3MgaXMgbm90IHRoZSBzYW1lIGFzIHRoZSBvbGQgb25lLlxuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICByYW5kQ2xhc3MgPSBhcnJbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogYXJyLmxlbmd0aCldXG4gICAgICAgICAgICB9IHdoaWxlIChyYW5kQ2xhc3MgPT09IHByZXYpXG5cbiAgICAgICAgICAgIGNvbnN0IHJhbmRJbnRlcnZhbCA9IE1hdGguZmxvb3IoXG4gICAgICAgICAgICAgIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkgKyBtaW5cbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIGlmIChwcmV2KSB7XG4gICAgICAgICAgICAgIC8vIENsZWFuIHVwXG4gICAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUocHJldilcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsLmNsYXNzTGlzdC5hZGQocmFuZENsYXNzKVxuICAgICAgICAgICAgc2V0VGltZW91dChcbiAgICAgICAgICAgICAgcmFuZENsYXNzT25SYW5kSW50ZXJ2YWwsXG4gICAgICAgICAgICAgIHJhbmRJbnRlcnZhbCxcbiAgICAgICAgICAgICAgaW1nLFxuICAgICAgICAgICAgICBhcnIsXG4gICAgICAgICAgICAgIG1pbixcbiAgICAgICAgICAgICAgbWF4LFxuICAgICAgICAgICAgICByYW5kQ2xhc3NcbiAgICAgICAgICAgIClcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gQWxsIHRoYXQgbmVlZHMgbXVsdGlwbGUgZnJhbWVzLCBzZXQgdXAgaW5kaXZpZHVhbCBzZXR0aW5ncyBoZXJlXG4gICAgICAgICAgaWYgKHByb3RvLnRvZ2dsZUNsYXNzZXMuaW5jbHVkZXMoJ2hhbmRzMScpKSB7XG4gICAgICAgICAgICAvLyBUb2dnbGUgdGhlIGhhbmRzXG4gICAgICAgICAgICByYW5kQ2xhc3NPblJhbmRJbnRlcnZhbChpbWcsIHByb3RvLnRvZ2dsZUNsYXNzZXMsIDE1MCwgMjAwKVxuICAgICAgICAgIH0gZWxzZSBpZiAocHJvdG8udG9nZ2xlQ2xhc3Nlcy5pbmNsdWRlcygnZXllczEnKSkge1xuICAgICAgICAgICAgLy8gVG9nZ2xlIHRoZSBleWVzXG4gICAgICAgICAgICByYW5kQ2xhc3NPblJhbmRJbnRlcnZhbChpbWcsIHByb3RvLnRvZ2dsZUNsYXNzZXMsIDUwLCAxMDAwKVxuICAgICAgICAgIH1cbiAgICAgICAgfSAqL1xuICAgICAgfVxuICAgICAgZWwuYXBwZW5kKGNvbnRlbnQpXG5cbiAgICAgIHJldHVybiBlbFxuICAgIH0pXG5cbiAgICAvLyBDcmVhdGUgdGhlICNwYXJhbGxheFxuICAgIGNvbnN0IHBhcmFsbGF4ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICBwYXJhbGxheC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3BhcmFsbGF4JylcbiAgICBwYXJhbGxheC5hcHBlbmQoLi4ucGFyYWxsYXhMYXllcnMpXG5cbiAgICAvLyBEZXZhc3RhdGUgYW5kIHJlY3JlYXRlIHRoZSA8Ym9keT5cbiAgICBkb2N1bWVudC5ib2R5LmlubmVySFRNTCA9ICcnXG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChwYXJhbGxheClcblxuICAgIC8vIDIuIEdyZWV0aW5nXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgd2VsY29tZVVzKCksIHRydWUpIC8vTm90IGEgdHlwbzogQ2FsbCB3ZWxjb21lVXMgaW5pdGlhbGx5IGFuZCB0aGVuIG9uIHJlc2l6ZS4gKE5vdGljZSB0aGF0IHdlbGNvbWVVcyByZXR1cm5zIGl0c2VsZilcbiAgICB9LCAxNTApXG4gIH0gZWxzZSBpZiAoc3AubG9hZCkge1xuICB9IGVsc2UgaWYgKHNwLmJlZm9yZXVubG9hZCkge1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4UGFnZVxuIiwiaW1wb3J0IHhtbDJqc29uIGZyb20gJy4uL3NjcmlwdHMveG1sMmpzb24nXG5cbmNvbnN0IGZvb3RlckdlbmVyYXRvciA9IHhtbCA9PiB7XG4gIGNvbnN0IGpzb24gPSB4bWwyanNvbih4bWwpXG5cbiAgLy8gU29jaWFsTWVkaWFcbiAgY29uc3Qgc29jbWVkaWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBzb2NtZWRpYS5pZCA9ICdzb2NtZWRpYSdcbiAgY29uc3Qgc29jaWFsTWVkaWFCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBzb2NpYWxNZWRpYUJveC5jbGFzc05hbWUgPSAnc29jTWVkaWFCb3gnXG4gIHNvY2lhbE1lZGlhQm94LmlubmVySFRNTCA9IGA8eG1sPiR7XG4gICAgeG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzb2NtZWRpYScpWzBdLm91dGVySFRNTFxuICB9PC94bWw+YCAvLyBUaGUgeG1sIHdpbGwgbGF0ZXIgYmUgcmVwbGFjZWQuIExvb2sgYXQgYWN0aW9uIGFueS5qc1xuICBzb2NtZWRpYS5hcHBlbmQoc29jaWFsTWVkaWFCb3gpXG5cbiAgLy8gU3Vic2NyaWJlIChOT1RFOiBGb3Igbm93IHRoaXMgY29tcG9uZW50IGlzIG5vdCBuZWVkZWQsIHRoZXJlZm9yZSBpdCB3b24ndCBiZSBkaXNwbGF5ZWQpXG4gIC8qXG4gIGNvbnN0IHN1YnNjcmliZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIHN1YnNjcmliZS5pZCA9ICdzdWJzY3JpYmUnXG4gIGNvbnN0IGN0YSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2g1JylcbiAgY3RhLmlkID0gJ2N0YSdcbiAgY3RhLmlubmVySFRNTCA9IGpzb25bJ1NVQlNDUklCRSddWydDVEEnXVxuICBjb25zdCBzdWJUd2l0dGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgc3ViVHdpdHRlci5pZCA9ICdzdWJUd2l0dGVyJ1xuICBjb25zdCBzdWJFbWFpbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIHN1YkVtYWlsLmlkID0gJ3N1YkVtYWlsJ1xuICBjb25zdCBzdWJSc3MgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBzdWJSc3MuaWQgPSAnc3ViUnNzJ1xuICBzdWJzY3JpYmUuYXBwZW5kKGN0YSwgc3ViVHdpdHRlciwgc3ViRW1haWwsIHN1YlJzcylcbiovXG5cbiAgLy8gSW5mb1xuICBjb25zdCBpbmZvID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgaW5mby5pZCA9ICdpbmZvJ1xuICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBkaXYuaW5uZXJIVE1MID0gYEJ1aWx0IHdpdGggRW1hY3MgT3JnLW1vZGUg4oCiIDxhIGhyZWY9J2h0dHBzOi8vZ2l0aHViLmNvbS90aGV3ZWJtYXN0ZXJwL3RoZXdlYm1hc3RlcnAuY29tJz5Db2RlPC9hPiBvcGVuIHNvdXJjZWQg4oCiIFJlYWQgdGhlIDxhIGhyZWY9J3ByaXZhY3ktcG9saWN5Lmh0bWwnPlByaXZhY3kgUG9saWN5PC9hPiDigKIgPGEgaHJlZj1cImNvbnRhY3QuaHRtbFwiPkNvbnRhY3QgbWU8L2E+YFxuICBpbmZvLmFwcGVuZENoaWxkKGRpdilcblxuICAvLyBCb3R0b21cbiAgY29uc3QgYm90dG9tID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgYm90dG9tLmlkID0gJ2JvdHRvbSdcblxuICAvLyBBc3NlbWJsZSBhbmQgJ3NwaXQnIHRoZSBmb290ZXJcbiAgY29uc3QgZm9vdGVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9vdGVyJylcbiAgZm9vdGVyLmFwcGVuZChzb2NtZWRpYSwgLypzdWJzY3JpYmUqLyBpbmZvLCBib3R0b20pXG4gIHJldHVybiBmb290ZXJcbn1cblxuZXhwb3J0IGRlZmF1bHQgZm9vdGVyR2VuZXJhdG9yXG4iLCJjb25zdCBzb2NpYWxNZWRpYUJveEdlbmVyYXRvciA9IChhcnIsIGljb25zQmFzZVBhdGgpID0+IHtcbiAgLy8gaW5wdXQgZm9ybWF0OiBbe2xhYmVsOiBnaXRodWIsIGhyZWY6ICdodHRwczovL3d3dy5naXRodWIuY29tJywgaWNvbjogJy4vaWNvbnMvaWNvbi5wbmcnIH0sIHsuLi59XVxuXG4gIGNvbnN0IGJveCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGJveC5jbGFzc05hbWUgPSAnc29jTWVkaWFCb3gnXG5cbiAgYXJyID0gYXJyLm1hcChlbnRyeSA9PiB7XG4gICAgY29uc3QgcHJvZmlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKVxuICAgIHByb2ZpbGUuY2xhc3NOYW1lID0gJ3Byb2ZpbGUnXG4gICAgcHJvZmlsZS5ocmVmID0gZW50cnlbJ0hSRUYnXVxuXG4gICAgY29uc3QgaWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2knKVxuICAgIGljb24udGl0bGUgPSBlbnRyeVsnTEFCRUwnXVxuXG4gICAgY29uc3QgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpXG4gICAgcmVxdWVzdC5vcGVuKCdHRVQnLCBgJHtpY29uc0Jhc2VQYXRofS8ke2VudHJ5WydJQ09OJ119YCwgZmFsc2UpIC8vIGBmYWxzZWAgbWFrZXMgdGhlIHJlcXVlc3Qgc3luY2hyb25vdXNcbiAgICByZXF1ZXN0LnNlbmQobnVsbClcbiAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCkge1xuICAgICAgaWNvbi5pbm5lckhUTUwgPSByZXF1ZXN0LnJlc3BvbnNlVGV4dFxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zb2xlLmVycm9yKGBFcnJvciAke3JlcXVlc3Quc3RhdHVzfSBmZXRjaGluZyBpY29ucy5gKVxuICAgIH1cblxuICAgIHByb2ZpbGUuYXBwZW5kQ2hpbGQoaWNvbilcbiAgICByZXR1cm4gcHJvZmlsZVxuICB9KVxuXG4gIGJveC5hcHBlbmQoLi4uYXJyKVxuICByZXR1cm4gYm94XG59XG5cbmV4cG9ydCBkZWZhdWx0IHNvY2lhbE1lZGlhQm94R2VuZXJhdG9yXG4iLCJjb25zdCBpY29uR2VuZXJhdG9yID0gKGxhYmVsLCBpbm5lckhUTUwsIHRvb2x0aXApID0+IHtcbiAgY29uc3QgaWNvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2knKVxuICBpY29uLmNsYXNzTGlzdC5hZGQoYCR7bGFiZWx9LWljb25gKVxuICBpY29uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCB0b29sdGlwKVxuICBpY29uLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKVxuICAvLyBZb3UgY2FuJ3QgcHJvcGVybHkgZ2VuZXJhdGUgc3ZnIGVsZW1lbnQgd2l0aCBkb2N1bWVudC5jcmVhdGVFbGVtZW50LiBZb3UgaGF2ZSB0byB1c2UgY3JlYXRlRWxlbWVudE5TLCBhcyBmb2xsb3dzOlxuICBjb25zdCBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgJ3N2ZycpXG4gIC8vIEZvciBtb3JlIG9uIHRoZSB0b3BpYywgc2VlIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI4NzM0NjI4L2hvdy1jYW4taS1zZXQtYW4tYXR0cmlidXRlLXdpdGgtY2FzZS1zZW5zaXRpdmUtbmFtZS1pbi1hLWphdmFzY3JpcHQtZ2VuZXJhdGVkLWVsLzI4NzM0OTU0XG4gIHN2Zy5jbGFzc0xpc3QuYWRkKCdmZWF0aGVyJywgYGZlYXRoZXItJHtsYWJlbH1gKVxuICBzdmcuc2V0QXR0cmlidXRlKCdmaWxsJywgJ25vbmUnKVxuICBzdmcuc2V0QXR0cmlidXRlKCdzdHJva2UnLCAnY3VycmVudENvbG9yJylcbiAgc3ZnLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVjYXAnLCAncm91bmQnKVxuICBzdmcuc2V0QXR0cmlidXRlKCdzdHJva2UtbGluZWpvaW4nLCAncm91bmQnKVxuICBzdmcuc2V0QXR0cmlidXRlKCdzdHJva2Utd2lkdGgnLCAnMicpXG4gIHN2Zy5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCAnMCAwIDI0IDI0JylcbiAgc3ZnLnNldEF0dHJpYnV0ZSgneG1sbnMnLCAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnKVxuICBzdmcuaW5uZXJIVE1MID0gaW5uZXJIVE1MXG4gIGljb24uYXBwZW5kKHN2ZylcblxuICByZXR1cm4gaWNvblxufVxuXG5jb25zdCB0aGVtZUNoYW5nZXJCdG4gPSAodG9vbHRpcCwgb25DbGljaykgPT4ge1xuICAvL2NvbnN0IGNvbnN0cnVjdGlvblNpdGVzID0gWy4uLmRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpXVxuXG4gIGNvbnN0IGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpXG5cbiAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25DbGljaylcblxuICBjb25zdCBtb29uSW5IVE1MID1cbiAgICAnPHBhdGggZD1cIk0yMSAxMi43OUE5IDkgMCAxIDEgMTEuMjEgMyA3IDcgMCAwIDAgMjEgMTIuNzl6XCIvPidcbiAgY29uc3Qgc3VuSW5IVE1MID1cbiAgICAnPGNpcmNsZSBjeD1cIjEyXCIgY3k9XCIxMlwiIHI9XCI1XCI+PC9jaXJjbGU+PGxpbmUgeDE9XCIxMlwiIHgyPVwiMTJcIiB5MT1cIjFcIiB5Mj1cIjNcIj48L2xpbmU+PGxpbmUgeDE9XCIxMlwiIHgyPVwiMTJcIiB5MT1cIjIxXCIgeTI9XCIyM1wiPjwvbGluZT48bGluZSB4MT1cIjQuMjJcIiB4Mj1cIjUuNjRcIiB5MT1cIjQuMjJcIiB5Mj1cIjUuNjRcIj48L2xpbmU+PGxpbmUgeDE9XCIxOC4zNlwiIHgyPVwiMTkuNzhcIiB5MT1cIjE4LjM2XCIgeTI9XCIxOS43OFwiPjwvbGluZT48bGluZSB4MT1cIjFcIiB4Mj1cIjNcIiB5MT1cIjEyXCIgeTI9XCIxMlwiPjwvbGluZT48bGluZSB4MT1cIjIxXCIgeDI9XCIyM1wiIHkxPVwiMTJcIiB5Mj1cIjEyXCI+PC9saW5lPjxsaW5lIHgxPVwiNC4yMlwiIHgyPVwiNS42NFwiIHkxPVwiMTkuNzhcIiB5Mj1cIjE4LjM2XCI+PC9saW5lPjxsaW5lIHgxPVwiMTguMzZcIiB4Mj1cIjE5Ljc4XCIgeTE9XCI1LjY0XCIgeTI9XCI0LjIyXCI+PC9saW5lPidcbiAgY29uc3QgW21vb25JY29uLCBzdW5JY29uXSA9IFtcbiAgICBpY29uR2VuZXJhdG9yKCdtb29uJywgbW9vbkluSFRNTCwgdG9vbHRpcCksXG4gICAgaWNvbkdlbmVyYXRvcignc3VuJywgc3VuSW5IVE1MLCB0b29sdGlwKSxcbiAgXVxuXG4gIGNvbnN0IGJ0blRleHRFbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKVxuICBidG5UZXh0RWwuY2xhc3NMaXN0LmFkZCgnc3Itb25seScpXG4gIGJ0blRleHRFbC50ZXh0Q29udGVudCA9IHRvb2x0aXBcblxuICBidXR0b24uYXBwZW5kKG1vb25JY29uLCBzdW5JY29uLCBidG5UZXh0RWwpXG5cbiAgcmV0dXJuIGJ1dHRvblxufVxuXG5leHBvcnQgZGVmYXVsdCB0aGVtZUNoYW5nZXJCdG5cbiIsImNvbnN0IG1hdG9tb0luaXQgPSAoKSA9PiB7XG4gIC8vIFRPRE86IEVuYWJsZSBhbmQgZGVidWcgdGhpcyBzY3JpcHQgYWZ0ZXIgcHVzaGVkIHRvIHByb2R1Y3Rpb25cbiAgLypcbiAgdmFyIF9wYXEgPSAod2luZG93Ll9wYXEgPSB3aW5kb3cuX3BhcSB8fCBbXSlcbiAgLy8gdHJhY2tlciBtZXRob2RzIGxpa2UgXCJzZXRDdXN0b21EaW1lbnNpb25cIiBzaG91bGQgYmUgY2FsbGVkIGJlZm9yZSBcInRyYWNrUGFnZVZpZXdcIlxuICBfcGFxLnB1c2goWyd0cmFja1BhZ2VWaWV3J10pXG4gIF9wYXEucHVzaChbJ2VuYWJsZUxpbmtUcmFja2luZyddKVxuICA7KGZ1bmN0aW9uKCkge1xuXHR2YXIgdSA9ICcvL21hdG9tby50aGV3ZWJtYXN0ZXJwLmNvbS8nXG5cdF9wYXEucHVzaChbJ3NldFRyYWNrZXJVcmwnLCB1ICsgJ21hdG9tby5waHAnXSlcblx0X3BhcS5wdXNoKFsnc2V0U2l0ZUlkJywgJzEnXSlcblx0dmFyIGQgPSBkb2N1bWVudCxcblx0XHRnID0gZC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSxcblx0XHRzID0gZC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JylbMF1cblx0Zy5hc3luYyA9IHRydWVcblx0Zy5zcmMgPSB1ICsgJ21hdG9tby5qcydcblx0cy5wYXJlbnROb2RlLmluc2VydEJlZm9yZShnLCBzKVxuICB9KSgpKi9cbn1cblxuZXhwb3J0IGRlZmF1bHQgbWF0b21vSW5pdFxuIiwiZnVuY3Rpb24geG1sMmpzb24oeG1sKSB7XG4gIHRyeSB7XG4gICAgdmFyIG9iaiA9IHt9XG4gICAgaWYgKHhtbC5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhtbC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgaXRlbSA9IHhtbC5jaGlsZHJlbi5pdGVtKGkpXG4gICAgICAgIHZhciBub2RlTmFtZSA9IGl0ZW0ubm9kZU5hbWVcblxuICAgICAgICBpZiAodHlwZW9mIG9ialtub2RlTmFtZV0gPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBvYmpbbm9kZU5hbWVdID0geG1sMmpzb24oaXRlbSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAodHlwZW9mIG9ialtub2RlTmFtZV0ucHVzaCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdmFyIG9sZCA9IG9ialtub2RlTmFtZV1cblxuICAgICAgICAgICAgb2JqW25vZGVOYW1lXSA9IFtdXG4gICAgICAgICAgICBvYmpbbm9kZU5hbWVdLnB1c2gob2xkKVxuICAgICAgICAgIH1cbiAgICAgICAgICBvYmpbbm9kZU5hbWVdLnB1c2goeG1sMmpzb24oaXRlbSkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgb2JqID0geG1sLnRleHRDb250ZW50XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfSBjYXRjaCAoZSkge1xuICAgIGNvbnNvbGUubG9nKGUubWVzc2FnZSlcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCB4bWwyanNvblxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG5cdFx0Ly8gbm8gbW9kdWxlLmxvYWRlZCBuZWVkZWRcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXShtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuXHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG59XG5cbiIsIi8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb25zIGZvciBoYXJtb255IGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uZCA9IChleHBvcnRzLCBkZWZpbml0aW9uKSA9PiB7XG5cdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcblx0XHRpZihfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZGVmaW5pdGlvbiwga2V5KSAmJiAhX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIGtleSkpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBrZXksIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBkZWZpbml0aW9uW2tleV0gfSk7XG5cdFx0fVxuXHR9XG59OyIsIl9fd2VicGFja19yZXF1aXJlX18uZyA9IChmdW5jdGlvbigpIHtcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHRoaXMgfHwgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gJ29iamVjdCcpIHJldHVybiB3aW5kb3c7XG5cdH1cbn0pKCk7IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKSIsIi8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbl9fd2VicGFja19yZXF1aXJlX18uciA9IChleHBvcnRzKSA9PiB7XG5cdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG59OyIsInZhciBzY3JpcHRVcmw7XG5pZiAoX193ZWJwYWNrX3JlcXVpcmVfXy5nLmltcG9ydFNjcmlwdHMpIHNjcmlwdFVybCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5sb2NhdGlvbiArIFwiXCI7XG52YXIgZG9jdW1lbnQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLmcuZG9jdW1lbnQ7XG5pZiAoIXNjcmlwdFVybCAmJiBkb2N1bWVudCkge1xuXHRpZiAoZG9jdW1lbnQuY3VycmVudFNjcmlwdClcblx0XHRzY3JpcHRVcmwgPSBkb2N1bWVudC5jdXJyZW50U2NyaXB0LnNyY1xuXHRpZiAoIXNjcmlwdFVybCkge1xuXHRcdHZhciBzY3JpcHRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJzY3JpcHRcIik7XG5cdFx0aWYoc2NyaXB0cy5sZW5ndGgpIHNjcmlwdFVybCA9IHNjcmlwdHNbc2NyaXB0cy5sZW5ndGggLSAxXS5zcmNcblx0fVxufVxuLy8gV2hlbiBzdXBwb3J0aW5nIGJyb3dzZXJzIHdoZXJlIGFuIGF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgeW91IG11c3Qgc3BlY2lmeSBhbiBvdXRwdXQucHVibGljUGF0aCBtYW51YWxseSB2aWEgY29uZmlndXJhdGlvblxuLy8gb3IgcGFzcyBhbiBlbXB0eSBzdHJpbmcgKFwiXCIpIGFuZCBzZXQgdGhlIF9fd2VicGFja19wdWJsaWNfcGF0aF9fIHZhcmlhYmxlIGZyb20geW91ciBjb2RlIHRvIHVzZSB5b3VyIG93biBsb2dpYy5cbmlmICghc2NyaXB0VXJsKSB0aHJvdyBuZXcgRXJyb3IoXCJBdXRvbWF0aWMgcHVibGljUGF0aCBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgYnJvd3NlclwiKTtcbnNjcmlwdFVybCA9IHNjcmlwdFVybC5yZXBsYWNlKC8jLiokLywgXCJcIikucmVwbGFjZSgvXFw/LiokLywgXCJcIikucmVwbGFjZSgvXFwvW15cXC9dKyQvLCBcIi9cIik7XG5fX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBzY3JpcHRVcmwgKyBcIi4uL1wiOyIsImltcG9ydCBtYXRvbW9Jbml0IGZyb20gJy4vbWF0b21vSW5pdCdcblxuaW1wb3J0IGFueSBmcm9tICcuL2FjdGlvbnMvYW55J1xuaW1wb3J0IGluZGV4UGFnZSBmcm9tICcuL2FjdGlvbnMvaW5kZXhQYWdlJ1xuaW1wb3J0IGFib3V0UGFnZSBmcm9tICcuL2FjdGlvbnMvYWJvdXRQYWdlJ1xuaW1wb3J0IGNvbnRhY3RQYWdlIGZyb20gJy4vYWN0aW9ucy9jb250YWN0UGFnZSdcbmltcG9ydCBibG9nIGZyb20gJy4vYWN0aW9ucy9ibG9nJ1xuaW1wb3J0IGJsb2dQYWdlIGZyb20gJy4vYWN0aW9ucy9ibG9nUGFnZSdcbmltcG9ydCBibG9nQXJ0aWNsZSBmcm9tICcuL2FjdGlvbnMvYmxvZ0FydGljbGUnXG5cbmNvbnN0IENPTkZJRyA9IHtcbiAgZGVmYXVsdFRoZW1lOiAnZGFyaycsXG4gIHRoZW1lQXR0cmlidXRlOiAnZGF0YS10aGVtZScsXG4gIGljb25zQmFzZVBhdGg6ICcvY3NzL2ljb25zJyxcbn1cblxuY2xhc3MgUnVsZSB7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGNvbmRpdGlvbiwgYWN0aW9uLCBpZCkge1xuICAgIHRoaXMubmFtZSA9IG5hbWVcbiAgICB0aGlzLmNvbmRpdGlvbiA9IGNvbmRpdGlvblxuICAgIHRoaXMuYWN0aW9uID0gYWN0aW9uXG4gICAgdGhpcy5pZCA9IGlkXG4gIH1cbiAgc3RhdGljIGdlbkNvbmRpdChhcnIpIHtcbiAgICByZXR1cm4gcGF0aCA9PiB7XG4gICAgICAvLyBOT1RFOiBTb21ldGltZXMsIGlmIHRoZSBsaW5rIGhhcyBhIGRvdWJsZXNobGFzaCwgaXQgZmFpbHMgdGhlc2UgdGVzdHMgYW5kIHRoZVxuICAgICAgLy8gc2l0ZSBicmVha3MhIEkgZGlkbid0IHJlc29sdmUgdGhpcyBpbiB0aGUgZnJvbnQtZW5kIGJlY2F1c2UgZXZlbiBpZiBpIGRpZCBzbyxcbiAgICAgIC8vIGl0IHdvdWxkbid0IHNvbHZlIHRoZSBwcm9ibGVtIGluIGl0cyByb290OiBXaHkgdGhpcyB3aG9sZSB0aGluZyBkZXBlbmRzIG9uIHRoZSB1cmw/XG4gICAgICByZXR1cm4gYXJyLnNvbWUoc3RyID0+IHtcbiAgICAgICAgLypcbiAgICAgICAgY29uc29sZS5sb2coYENvbXBhcmluZzogJyR7c3RyfScgd2l0aCAnJHtwYXRofSdgKVxuICAgICAgICBjb25zb2xlLmxvZyhcbiAgICAgICAgICBgPT4gJHtzdHIgPT09IHBhdGh9IHx8XG4gICAgICAgICAgICAke3N0ciA9PT0gZGVjb2RlVVJJQ29tcG9uZW50KHBhdGgpfSB8fFxuICAgICAgICAgICAgJHtzdHIgPT09IGVuY29kZVVSSUNvbXBvbmVudChwYXRoKX1gXG4gICAgICAgICkqL1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgIHN0ciA9PT0gcGF0aCB8fFxuICAgICAgICAgIHN0ciA9PT0gZGVjb2RlVVJJQ29tcG9uZW50KHBhdGgpIHx8XG4gICAgICAgICAgc3RyID09PSBlbmNvZGVVUklDb21wb25lbnQocGF0aClcbiAgICAgICAgKVxuICAgICAgfSlcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgcnVsZXMgPSBbXG4gIG5ldyBSdWxlKCdhbnknLCAoKSA9PiB0cnVlLCBhbnkpLFxuICBuZXcgUnVsZShcbiAgICAnaW5kZXhQYWdlJyxcbiAgICBSdWxlLmdlbkNvbmRpdChbJy8nLCAnL2luZGV4JywgJy9pbmRleC5odG1sJywgJ2luZGV4J10pLFxuICAgIGluZGV4UGFnZSxcbiAgICAnaW5kZXgnXG4gICksXG4gIG5ldyBSdWxlKFxuICAgICdhYm91dFBhZ2UnLFxuICAgIFJ1bGUuZ2VuQ29uZGl0KFsnL2Fib3V0Lmh0bWwnLCAnL2Fib3V0JywgJ2Fib3V0J10pLFxuICAgIGFib3V0UGFnZSxcbiAgICAnYWJvdXQnXG4gICksXG4gIG5ldyBSdWxlKFxuICAgICdjb250YWN0UGFnZScsXG4gICAgUnVsZS5nZW5Db25kaXQoWycvY29udGFjdC5odG1sJywgJy9jb250YWN0JywgJ2NvbnRhY3QnXSksXG4gICAgY29udGFjdFBhZ2UsXG4gICAgJ2NvbnRhY3QnXG4gICksXG4gIG5ldyBSdWxlKCdibG9nJywgcGF0aCA9PiBwYXRoLmluY2x1ZGVzKCdibG9nJyksIGJsb2cpLFxuICBuZXcgUnVsZShcbiAgICAnYmxvZ1BhZ2UnLFxuICAgIFJ1bGUuZ2VuQ29uZGl0KFsnL2Jsb2cuaHRtbCcsICcvYmxvZycsICdibG9nJ10pLFxuICAgIGJsb2dQYWdlLFxuICAgICdibG9nJ1xuICApLFxuICBuZXcgUnVsZShcbiAgICAnYXJ0aWNsZScsXG4gICAgcGF0aCA9PiB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwYXRoLmluY2x1ZGVzKCdibG9nJykgJiZcbiAgICAgICAgIVJ1bGUuZ2VuQ29uZGl0KFsnL2Jsb2cuaHRtbCcsICcvYmxvZycsICdibG9nJ10pKHBhdGgpXG4gICAgICApXG4gICAgfSxcbiAgICBibG9nQXJ0aWNsZSxcbiAgICAnYXJ0aWNsZSdcbiAgKSxcbl1cblxuY29uc3QgbWFpbiA9IChldmVudCwgY29uZmlnKSA9PiB7XG4gIGNvbnN0IHN0YXR1cyA9IGV2ZW50LnR5cGVcbiAgY29uc3QgcGF0aG5hbWUgPSB3aW5kb3cubG9jYXRpb24ucGF0aG5hbWVcbiAgY29uc3QgbWF0Y2hpbmcgPSBydWxlcy5maWx0ZXIoZW50cnkgPT4ge1xuICAgIC8vIGNvbnNvbGUubG9nKGVudHJ5LmNvbmRpdGlvbilcbiAgICByZXR1cm4gZW50cnkuY29uZGl0aW9uKHBhdGhuYW1lKVxuICB9KVxuICBjb25zdCBzdGFydGVyUGFjayA9IHtcbiAgICBjb25maWc6IGNvbmZpZyxcbiAgICBzdGF0dXM6IHN0YXR1cyxcbiAgICBET01Db250ZW50TG9hZGVkOiBzdGF0dXMgPT09ICdET01Db250ZW50TG9hZGVkJyxcbiAgICBsb2FkOiBzdGF0dXMgPT09ICdsb2FkJyxcbiAgICBiZWZvcmV1bmxvYWQ6IHN0YXR1cyA9PT0gJ2JlZm9yZXVubG9hZCcsXG4gICAgaHRtbDogZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgIGhlYWQ6IGRvY3VtZW50LmhlYWQsXG4gICAgYm9keTogZG9jdW1lbnQuYm9keSxcbiAgICBwcmVhbWJsZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3ByZWFtYmxlJyksXG4gICAgdG9wbmF2OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndG9wbmF2JyksXG4gICAgY29udGVudDogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRlbnQnKSxcbiAgICBwb3N0YW1ibGU6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdwb3N0YW1ibGUnKSxcbiAgICBmb290ZXI6IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdmb290ZXInKVswXSxcbiAgICBsb2c6IGNvbnNvbGUubG9nLFxuICAgIGVycjogY29uc29sZS5lcnJvcixcbiAgICBtYXRjaGVkUnVsZXNMaXN0OiBtYXRjaGluZyxcbiAgICBzZXRBY3RpdmVOYXZFbnRyOiBjbGFzc05hbWUgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc05hbWUpWzBdXG4gICAgICB0YXJnZXQuc2V0QXR0cmlidXRlKCdkYXRhLWN1cnJlbnQnLCAnJylcbiAgICB9LFxuICAgIG9wZW5JbWFnZU9uOiBldmVudCA9PiB7XG4gICAgICBjb25zdCB1cmwgPSBldmVudC50YXJnZXQuZ2V0QXR0cmlidXRlKCdzcmMnKVxuICAgICAgd2luZG93Lm9wZW4odXJsLCAnX2JsYW5rJykuZm9jdXMoKVxuICAgIH0sXG4gIH1cbiAgbWF0Y2hpbmcuZm9yRWFjaChlbnRyeSA9PiB7XG4gICAgaWYgKGVudHJ5Lm5hbWUgPT09ICdhbnknKSByZXR1cm5cbiAgICBzdGFydGVyUGFjay5lbnRyeU5hbWUgPSBlbnRyeS5uYW1lIHx8IG51bGxcbiAgICBlbnRyeS5hY3Rpb24oc3RhcnRlclBhY2spXG4gIH0pXG4gIC8vICdhbnknIHNob3VsZCBiZSBjYWxsZWQgbGFzdFxuICBtYXRjaGluZy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICBpZiAoZW50cnkubmFtZSA9PT0gJ2FueScpIHtcbiAgICAgIHN0YXJ0ZXJQYWNrLmVudHJ5TmFtZSA9ICdhbnknXG4gICAgICBlbnRyeS5hY3Rpb24oc3RhcnRlclBhY2spXG4gICAgfVxuICB9KVxuXG4gIC8vIEluaXRpYWxpemUgbWF0b21vXG4gIG1hdG9tb0luaXQoKVxufVxuXG5jb25zdCBtYWluQ2FsbGVyID0gZXZlbnQgPT4ge1xuICBtYWluKGV2ZW50LCBDT05GSUcpXG59XG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIG1haW5DYWxsZXIpIC8vIERPTSBsb2FkZWRcbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgbWFpbkNhbGxlcikgLy8gRE9NICsgc3RhdGljIGxvYWRlZFxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIG1haW5DYWxsZXIpIC8vIHVubG9hZGVkIChwcmVzc2luZyBiYWNrLCB2aXNpdGluZyBsaW5rIC4uLilcbiIsImV4cG9ydCBkZWZhdWx0IF9fd2VicGFja19wdWJsaWNfcGF0aF9fICsgXCJjc3Mvc3R5bGUubWluLmNzc1wiOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==