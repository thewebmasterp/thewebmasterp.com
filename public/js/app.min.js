/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./content/js/actions/aboutPage.js":
/*!*****************************************!*\
  !*** ./content/js/actions/aboutPage.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const aboutPage = sp => {
  sp.log(`${sp.entryName} - ${sp.status}`)
  if (sp.DOMContentLoaded) {
    // Set the active navigation entry
    sp.setActiveNavEntr('aboutLink')

    // Give some custom structure to aboutme
    const me = document.getElementById('me')
    me.addEventListener('load', () => {
      const textAboutme = document.getElementById('text-aboutme')
      const figure = me.parentElement
      const figureHTML = figure.cloneNode(true).outerHTML
      figure.remove()
      textAboutme.innerHTML = `${figureHTML}<div>${textAboutme.innerHTML}</div>`
      document.getElementById('me').addEventListener('click', sp.openImageOn)
    })
  } else if (sp.load) {
  } else if (sp.beforeunload) {
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (aboutPage);


/***/ }),

/***/ "./content/js/actions/any.js":
/*!***********************************!*\
  !*** ./content/js/actions/any.js ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _components_themeChanger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/themeChanger */ "./content/js/components/themeChanger.js");
/* harmony import */ var _components_footerGenerator__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components/footerGenerator */ "./content/js/components/footerGenerator.js");
/* harmony import */ var _components_socialMediaBoxGenerator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components/socialMediaBoxGenerator */ "./content/js/components/socialMediaBoxGenerator.js");
/* harmony import */ var _scripts_xml2json__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../scripts/xml2json */ "./content/js/scripts/xml2json.js");






const any = sp => {
  sp.log(`${sp.entryName} - ${sp.status}`)

  // Initialize theme
  const attr = sp.config.themeAttribute
  let theme = localStorage.getItem(attr)
  if (!theme) {
    localStorage.setItem(attr, sp.config.defaultTheme)
    theme = sp.config.defaultTheme
  }
  document?.documentElement?.setAttribute?.(attr, theme)
  window?.REMARK42?.changeTheme?.(theme)
  setTimeout(() => {
    // Just to make sure
    window?.REMARK42?.changeTheme?.(theme)
  }, 1000)

  if (sp.DOMContentLoaded) {
    // Add a class of .preload to the body (and when the whole page is loaded - Remove it).
    document.body.classList.add('preload')

    // Apply the appropriate id to the current page's body
    const withIdOnly = sp.matchedRulesList.filter(entry => entry.id)
    if (!withIdOnly[0]) {
      sp.err('No matching rules for the current page!')
    }
    document.body.setAttribute('id', withIdOnly[0]?.id || 'undefined')

    // Every link pointing to an outside website should be opened in a new tab
    // Every link href should be formatted (I understand JS more than elisp... sry)
    const contentAnchors = document.getElementsByTagName('a')
    // NOTE: If you use any special characters like # or sth else in your filenames, list them here.
    const specChar = ['#']
    ;[...contentAnchors].forEach(a => {
      const href = a.getAttribute('href')
      if (href.startsWith('https://') || href.startsWith('http://')) {
        a.setAttribute('target', '_blank')
      } else if (
        href
          .substring(1)
          .split('')
          .some(str => specChar.includes(str)) ||
        decodeURIComponent(href.substring(1))
          .split('')
          .some(str => specChar.includes(str))
      ) {
        console.log(href)
        const newHref = encodeURIComponent(href)
        a.setAttribute('href', newHref)
      }
    })

    // Append a CSS class .clicked to a clicked anchor from #topnav
    const topNavLinks = sp.topnav.getElementsByTagName('a')
    ;[...topNavLinks].forEach(a => {
      a.addEventListener('click', e => {
        e.target.classList.add('clicked')
      })
    })

    // Theme changer controls
    const themSwrConstructionSites = [
      ...document.querySelectorAll('.theme-changer'),
    ]
    themSwrConstructionSites.forEach(site => {
      const btn = (0,_components_themeChanger__WEBPACK_IMPORTED_MODULE_0__["default"])('Toggle between dark and light mode', () => {
        //btn onclick callback
        const attr = sp.config.themeAttribute
        const currThemeFromAttr = document.documentElement.getAttribute(attr)
        const currThemeFromLStorage = localStorage.getItem(attr)
        if (currThemeFromAttr !== currThemeFromLStorage)
          console.warn('Theme attribute - Local storage dismatch!')
        const currentTheme = currThemeFromAttr
        if (currentTheme === 'light') {
          // Switch to dark
          localStorage.setItem(attr, 'dark')
          document.documentElement.setAttribute(attr, 'dark')
          window?.REMARK42?.changeTheme?.('dark')
        } else if (currentTheme === 'dark') {
          // Switch to light
          localStorage.setItem(attr, 'light')
          document.documentElement.setAttribute(attr, 'light')
          window?.REMARK42?.changeTheme?.('light')
        }
        if (site.parentNode.getAttribute('class') === 'sparse') {
          site.classList.add('top-level')
        }
      })
      if (site.parentNode.getAttribute('class') === 'sparse') {
        site.classList.add('top-level')
      }
      site.append(btn)
    })

    /*
    ;[...document.querySelectorAll('.theme-changer > button')].forEach(btn => {
      btn.addEventListener('click', () => {
        //Implement the local storage and DOM toggle
        sp.log('.theme-changer button clicked')
        const currentTheme = document.documentElement.getAttribute(attr)
        if (currentTheme === 'light') {
          // Switch to dark
          localStorage.setItem(attr, 'dark')
          document.documentElement.setAttribute(attr, 'dark')
          window?.REMARK42?.changeTheme?.('dark')
        } else if (currentTheme === 'dark') {
          // Switch to light
          localStorage.setItem(attr, 'light')
          document.documentElement.setAttribute(attr, 'light')
          window?.REMARK42?.changeTheme?.('light')
        } 

        // Add some cool styling to the button itself to indicate theme
      })
    })*/

    // Every image in #content, on click should be opened in a new tab.
    const imgs = sp.content?.getElementsByTagName('img')
    ;[...imgs].forEach(img => {
      img.addEventListener('click', sp.openImageOn)
    })
  } else if (sp.load) {
    // Remove the class of .preload of the body when the whole page's loaded.
    document.body.classList.remove('preload')

    // Remove the colon at the end of code line number
    ;[...document.getElementsByClassName('linenr')].forEach(line => {
      line.innerHTML = line.innerHTML.slice(0, -2).concat(' ')
    })

    //Make the footer
    const footer = (0,_components_footerGenerator__WEBPACK_IMPORTED_MODULE_1__["default"])(
      document.getElementById('postamble').getElementsByTagName('xml')[0]
    )
    //postamble.innerHTML += footer.outerHTML
    postamble.appendChild(footer)

    // Process .socMediaBox
    const socMediaBoxes = document.getElementsByClassName('socMediaBox')
    ;[...socMediaBoxes].forEach(socMediaBox => {
      const xml = socMediaBox.getElementsByTagName('xml')[0]
      if (xml) {
        const json = (0,_scripts_xml2json__WEBPACK_IMPORTED_MODULE_3__["default"])(xml)
        socMediaBox.innerHTML = (0,_components_socialMediaBoxGenerator__WEBPACK_IMPORTED_MODULE_2__["default"])(
          json['SOCMEDIA']['ENTRY'],
          sp.config.iconsBasePath
        ).outerHTML
      } else {
        console.error('missing xml in .socMediaBox!')
      }
    })
  } else if (sp.beforeunload) {
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (any);


/***/ }),

/***/ "./content/js/actions/blog.js":
/*!************************************!*\
  !*** ./content/js/actions/blog.js ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const blog = sp => {
  sp.log(`${sp.entryName} - ${sp.status}`)
  if (sp.DOMContentLoaded) {
    // Set the active navigation entry
    sp.setActiveNavEntr('blogLink')
  } else if (sp.load) {
  } else if (sp.beforeunload) {
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (blog);


/***/ }),

/***/ "./content/js/actions/blogArticle.js":
/*!*******************************************!*\
  !*** ./content/js/actions/blogArticle.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const blogArticle = sp => {
  sp.log(`${sp.entryName} - ${sp.status}`)
  if (sp.DOMContentLoaded) {
    // Get date passed through an html comment inside <head>
    const date = document.head.innerHTML
      .split('\n')[1]
      .replace(/<!-- | -->/g, '')

    // Get author and description from some <meta>s in <head>
    const author = document.querySelector('meta[name="author"]').content
    const description = document.querySelector('meta[name="description"]')
      .content

    // Structure the fetched metadata to be inserted on the right place
    const meta = ` <div id="ArticleMetaData">
Last change: ${date}<br>
Author: <a href="/about.html">${author}</a>
</div>`
    const descriptionHTML = `<p id="description">${description}</p>`

    // Insert the metadata
    const header = document
      .getElementById('content')
      .getElementsByTagName('header')[0]
    header.innerHTML = header.innerHTML + meta + descriptionHTML
  } else if (sp.load) {
  } else if (sp.beforeunload) {
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (blogArticle);


/***/ }),

/***/ "./content/js/actions/blogPage.js":
/*!****************************************!*\
  !*** ./content/js/actions/blogPage.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const blogPage = sp => {
  sp.log(`${sp.entryName} - ${sp.status}`)
  if (sp.DOMContentLoaded) {
    // Replace default section headings (arch/ js/ for example) with custom ones
    const mapTo = {
      'Desktop Setup/': {
        title: 'Optimizing your Linux desktop setup for programming',
        description:
          'Let the articles under this section be a compendium - An essence of my hard-learned lessons regarding Linux and its configuration as a maximum productivity, programming desktop OS.',
      },
      'webmaster_project/': {
        title: 'Master JavaScript',
        description:
          "Every JavaScript thing that got my interest and inspired me, I'll write a post about it and it will be listed here.",
      },
    }
    // Do it
    const entries = document.querySelectorAll('#entries > ul > li')
    entries.forEach(li => {
      const target = li.getElementsByTagName('b')[0]
      const inTarget = target.textContent
      Object.keys(mapTo).forEach(key => {
        if (inTarget === key) {
          const toReplaceTarget = document.createElement('div')
          const title = document.createElement('h3')
          title.textContent = mapTo[key].title
          const description = document.createElement('p')
          description.textContent = mapTo[key].description
          const descriptionWrapper = document.createElement('ul')
          descriptionWrapper.appendChild(description)
          toReplaceTarget.append(title, descriptionWrapper)
          target.parentNode.replaceChild(toReplaceTarget, target)
        }
      })
    })
  } else if (sp.load) {
  } else if (sp.beforeunload) {
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (blogPage);


/***/ }),

/***/ "./content/js/actions/contactPage.js":
/*!*******************************************!*\
  !*** ./content/js/actions/contactPage.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const contactPage = sp => {
  sp.log(`${sp.entryName} - ${sp.status}`)
  if (sp.DOMContentLoaded) {
    const contactme = document.getElementById('contactme')
    if (!contactme) console.error('No #contactme!')
    contactme.addEventListener('submit', () => {
      const subject = document.getElementById('subject')
      const action = contactme.getAttribute('action')
      const subjectPrefix = '?subject='
      const i = action.indexOf(subjectPrefix) + subjectPrefix.length
      contactme.setAttribute('action', action.slice(0, i) + subject.value)
      console.log(subject.value)
    })

    const greeting = 'Hey thewebmasterp, hear this joke. '
    const jokes = [
      "What are a shark's two most favorite words?", // Man overboard!
      'Why are ghosts such bad liars?', // Because they are easy to see through.
      'What do you call a singing laptop?', // A Dell!
      'What did the buffalo say when his son left for college?', // Bison!
      'Why did the web developer drown?', // He had too many anchors.
      'Why was the JavaScript reality show cancelled after only one episode?', // People thought it seemed scripted.
      'How can you tell that a web developer is working?', // You can hear him Grunting!
      'Why does no one like jokes about descriptions, keywords, or character encodings?', // They’re too ‘meta’.
      'Why did the IP cross the subnet?', // Because the NAT said to!
      'Why was the class upset that its parent died?', // Because it wouldn’t be getting the inheritance!
      'How do you comfort a JavaScript bug?', // You console it.
      'Why was the web developer fired from her job?', // She did Less every day.
      'How does a web developer like his coffee?', // #000000
      'Why did the web developer send a few extra bucks to her hosting provider?', // Because she heard that she should always tip her server.
      'Why couldn’t the programmer work late into the night?', // She didn’t have a LAMP.
    ].map(joke => `${greeting}${joke}`)

    const prop = 'alreadySeenJokes'
    let alreadySeen = JSON.parse(localStorage.getItem(prop)) || []
    if (alreadySeen.length === jokes.length) {
      // If all jokes seen, reset the tracker
      localStorage.setItem(prop, JSON.stringify([]))
      alreadySeen = JSON.parse(localStorage.getItem(prop))
    }
    // Remove the already seen jokes
    alreadySeen.forEach(n => {
      jokes.splice(n, 1)
    })
    const randomJokeIndex = Math.floor(Math.random() * jokes.length)
    const newAlreadySeen = JSON.parse(localStorage.getItem(prop)) || []
    newAlreadySeen.push(randomJokeIndex)
    localStorage.setItem(prop, JSON.stringify(newAlreadySeen))

    // Apply the chosen joke as a placeholder for the message
    document
      .getElementById('message')
      .setAttribute('placeholder', jokes[randomJokeIndex])
  } else if (sp.load) {
  } else if (sp.beforeunload) {
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (contactPage);


/***/ }),

/***/ "./content/js/actions/indexPage.js":
/*!*****************************************!*\
  !*** ./content/js/actions/indexPage.js ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const indexPage = sp => {
  sp.log(`${sp.entryName} - ${sp.status}`)

  // Welcome the user with a nice falling-from-the-sky message
  const welcomeUs = () => {
    const welcome = document.getElementById('welcome')
    const pgw = window.innerWidth
    welcome.style.bottom = pgw < 550 ? '5em' : '4em'
    welcome.style.opacity = '1'
    return welcomeUs //Returns itself (needed for addEventListener in this case)
  }

  // When the index page is reloaded, its scroll should always start from top. Else, there's a bug with the #mask.
  if ('scrollRestoration' in history) {
    history.scrollRestoration = 'manual'
  }

  if (sp.DOMContentLoaded) {
    // Set the active navigation entry
    sp.setActiveNavEntr('homeLink')

    // Parralax

    // Unite #preamble, #content and #postamble "under the flag" of #preConPosWrapper
    const preamble = document.getElementById('preamble').cloneNode(true)
    const content = document.getElementById('content').cloneNode(true)
    const postamble = document.getElementById('postamble').cloneNode(true)
    const preConPosWrapper = document.createElement('div')
    preConPosWrapper.setAttribute('id', 'preConPosWrapper')
    // Some insignificant boxes with gradient / fill.
    const boxes = new Array(4).fill('').map((box, i) => {
      box = document.createElement('div')
      box.className = 'fakeBg'
      box.id = `fakeBg-${i + 1}`
      const fills = new Array(2).fill('').map((fill, i) => {
        fill = document.createElement('div')
        fill.className = `fill-${i + 1}`
        return fill
      })
      box.append(...fills)
      return box
    })
    preConPosWrapper.append(preamble, content, postamble, ...boxes)

    let parallaxLayers = new Array(6).fill('').map(str => ({}))
    parallaxLayers.forEach((proto, i) => {
      proto.classList = []
      proto.classList.push('layer', `layer-${i}`)
    })
    parallaxLayers = parallaxLayers.map((proto, i, arr) => {
      const el = document.createElement('div')
      el.classList.add(...proto.classList)

      let content = ''
      if (i === arr.length - 1) {
        // If it is the last element add main content to it
        content = preConPosWrapper
      } else {
        // Else, it is a frame of the parallax
        // Create a sub-element which holds parallax frame background
        const img = document.createElement('div')
        img.classList.add('img')
        content = img
        /*
		 * Deprecated!
		 * Changing element class every few milliseconds triggers a DOM re-render
		 * which is causing this choppiness.
		 * 
        if (proto.toggleClasses?.length >= 2) {
          // Pick a random string from the arr and apply it to the .img in random intervals
          const randClassOnRandInterval = (
            el,
            arr,
            min = 200,
            max = 600,
            prev
          ) => {
            let randClass
            //Make sure the randClass is not the same as the old one.
            do {
              randClass = arr[Math.floor(Math.random() * arr.length)]
            } while (randClass === prev)

            const randInterval = Math.floor(
              Math.random() * (max - min + 1) + min
            )
            if (prev) {
              // Clean up
              el.classList.remove(prev)
            }
            el.classList.add(randClass)
            setTimeout(
              randClassOnRandInterval,
              randInterval,
              img,
              arr,
              min,
              max,
              randClass
            )
          }
          // All that needs multiple frames, set up individual settings here
          if (proto.toggleClasses.includes('hands1')) {
            // Toggle the hands
            randClassOnRandInterval(img, proto.toggleClasses, 150, 200)
          } else if (proto.toggleClasses.includes('eyes1')) {
            // Toggle the eyes
            randClassOnRandInterval(img, proto.toggleClasses, 50, 1000)
          }
        } */
      }
      el.append(content)

      return el
    })

    // Create the #parallax
    const parallax = document.createElement('div')
    parallax.setAttribute('id', 'parallax')
    parallax.append(...parallaxLayers)

    // Devastate and recreate the <body>
    document.body.innerHTML = ''
    document.body.appendChild(parallax)

    // 2. Greeting
    setTimeout(() => {
      window.addEventListener('resize', welcomeUs(), true) //Not a typo: Call welcomeUs initially and then on resize. (Notice that welcomeUs returns itself)
    }, 150)
  } else if (sp.load) {
  } else if (sp.beforeunload) {
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (indexPage);


/***/ }),

/***/ "./content/js/components/footerGenerator.js":
/*!**************************************************!*\
  !*** ./content/js/components/footerGenerator.js ***!
  \**************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _scripts_xml2json__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../scripts/xml2json */ "./content/js/scripts/xml2json.js");


const footerGenerator = xml => {
  const json = (0,_scripts_xml2json__WEBPACK_IMPORTED_MODULE_0__["default"])(xml)

  // SocialMedia
  const socmedia = document.createElement('div')
  socmedia.id = 'socmedia'
  const socialMediaBox = document.createElement('div')
  socialMediaBox.className = 'socMediaBox'
  socialMediaBox.innerHTML = `<xml>${
    xml.getElementsByTagName('socmedia')[0].outerHTML
  }</xml>` // The xml will later be replaced. Look at action any.js
  socmedia.append(socialMediaBox)

  // Subscribe (NOTE: For now this component is not needed, therefore it won't be displayed)
  /*
  const subscribe = document.createElement('div')
  subscribe.id = 'subscribe'
  const cta = document.createElement('h5')
  cta.id = 'cta'
  cta.innerHTML = json['SUBSCRIBE']['CTA']
  const subTwitter = document.createElement('div')
  subTwitter.id = 'subTwitter'
  const subEmail = document.createElement('div')
  subEmail.id = 'subEmail'
  const subRss = document.createElement('div')
  subRss.id = 'subRss'
  subscribe.append(cta, subTwitter, subEmail, subRss)
*/

  // Info
  const info = document.createElement('div')
  info.id = 'info'
  const div = document.createElement('div')
  div.innerHTML = `Built with Emacs Org-mode • <a href='https://github.com/thewebmasterp/thewebmasterp.com'>Code</a> open sourced • Read the <a href='privacy-policy.html'>Privacy Policy</a> • <a href="contact.html">Contact me</a>`
  info.appendChild(div)

  // Bottom
  const bottom = document.createElement('div')
  bottom.id = 'bottom'

  // Assemble and 'spit' the footer
  const footer = document.createElement('footer')
  footer.append(socmedia, /*subscribe*/ info, bottom)
  return footer
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (footerGenerator);


/***/ }),

/***/ "./content/js/components/socialMediaBoxGenerator.js":
/*!**********************************************************!*\
  !*** ./content/js/components/socialMediaBoxGenerator.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const socialMediaBoxGenerator = (arr, iconsBasePath) => {
  // input format: [{label: github, href: 'https://www.github.com', icon: './icons/icon.png' }, {...}]

  const box = document.createElement('div')
  box.className = 'socMediaBox'

  arr = arr.map(entry => {
    const profile = document.createElement('a')
    profile.className = 'profile'
    profile.href = entry['HREF']

    const icon = document.createElement('i')
    icon.title = entry['LABEL']

    const request = new XMLHttpRequest()
    request.open('GET', `${iconsBasePath}/${entry['ICON']}`, false) // `false` makes the request synchronous
    request.send(null)
    if (request.status === 200) {
      icon.innerHTML = request.responseText
    } else {
      console.error(`Error ${request.status} fetching icons.`)
    }

    profile.appendChild(icon)
    return profile
  })

  box.append(...arr)
  return box
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (socialMediaBoxGenerator);


/***/ }),

/***/ "./content/js/components/themeChanger.js":
/*!***********************************************!*\
  !*** ./content/js/components/themeChanger.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const iconGenerator = (label, innerHTML, tooltip) => {
  const icon = document.createElement('i')
  icon.classList.add(`${label}-icon`)
  icon.setAttribute('title', tooltip)
  icon.setAttribute('aria-hidden', true)
  // You can't properly generate svg element with document.createElement. You have to use createElementNS, as follows:
  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg')
  // For more on the topic, see https://stackoverflow.com/questions/28734628/how-can-i-set-an-attribute-with-case-sensitive-name-in-a-javascript-generated-el/28734954
  svg.classList.add('feather', `feather-${label}`)
  svg.setAttribute('fill', 'none')
  svg.setAttribute('stroke', 'currentColor')
  svg.setAttribute('stroke-linecap', 'round')
  svg.setAttribute('stroke-linejoin', 'round')
  svg.setAttribute('stroke-width', '2')
  svg.setAttribute('viewBox', '0 0 24 24')
  svg.setAttribute('xmlns', 'http://www.w3.org/2000/svg')
  svg.innerHTML = innerHTML
  icon.append(svg)

  return icon
}

const themeChangerBtn = (tooltip, onClick) => {
  //const constructionSites = [...document.querySelectorAll(selector)]

  const button = document.createElement('button')

  button.addEventListener('click', onClick)

  const moonInHTML =
    '<path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"/>'
  const sunInHTML =
    '<circle cx="12" cy="12" r="5"></circle><line x1="12" x2="12" y1="1" y2="3"></line><line x1="12" x2="12" y1="21" y2="23"></line><line x1="4.22" x2="5.64" y1="4.22" y2="5.64"></line><line x1="18.36" x2="19.78" y1="18.36" y2="19.78"></line><line x1="1" x2="3" y1="12" y2="12"></line><line x1="21" x2="23" y1="12" y2="12"></line><line x1="4.22" x2="5.64" y1="19.78" y2="18.36"></line><line x1="18.36" x2="19.78" y1="5.64" y2="4.22"></line>'
  const [moonIcon, sunIcon] = [
    iconGenerator('moon', moonInHTML, tooltip),
    iconGenerator('sun', sunInHTML, tooltip),
  ]

  const btnTextEl = document.createElement('span')
  btnTextEl.classList.add('sr-only')
  btnTextEl.textContent = tooltip

  button.append(moonIcon, sunIcon, btnTextEl)

  return button
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (themeChangerBtn);


/***/ }),

/***/ "./content/js/matomoInit.js":
/*!**********************************!*\
  !*** ./content/js/matomoInit.js ***!
  \**********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
const matomoInit = () => {
  // TODO: Enable and debug this script after pushed to production
  console.log('hi from matomo!')

  var _paq = (window._paq = window._paq || [])
  // tracker methods like "setCustomDimension" should be called before "trackPageView"
  _paq.push(['trackPageView'])
  _paq.push(['enableLinkTracking'])
  ;(function() {
    var u = '//matomo.thewebmasterp.com/'
    _paq.push(['setTrackerUrl', u + 'matomo.php'])
    _paq.push(['setSiteId', '1'])
    var d = document,
      g = d.createElement('script'),
      s = d.getElementsByTagName('script')[0]
    g.async = true
    g.src = u + 'matomo.js'
    s.parentNode.insertBefore(g, s)
  })()
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (matomoInit);


/***/ }),

/***/ "./content/js/scripts/xml2json.js":
/*!****************************************!*\
  !*** ./content/js/scripts/xml2json.js ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
function xml2json(xml) {
  try {
    var obj = {}
    if (xml.children.length > 0) {
      for (var i = 0; i < xml.children.length; i++) {
        var item = xml.children.item(i)
        var nodeName = item.nodeName

        if (typeof obj[nodeName] == 'undefined') {
          obj[nodeName] = xml2json(item)
        } else {
          if (typeof obj[nodeName].push == 'undefined') {
            var old = obj[nodeName]

            obj[nodeName] = []
            obj[nodeName].push(old)
          }
          obj[nodeName].push(xml2json(item))
        }
      }
    } else {
      obj = xml.textContent
    }
    return obj
  } catch (e) {
    console.log(e.message)
  }
}

/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (xml2json);


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl + "../";
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
(() => {
var __webpack_exports__ = {};
/*!*****************************!*\
  !*** ./content/js/index.js ***!
  \*****************************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _matomoInit__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./matomoInit */ "./content/js/matomoInit.js");
/* harmony import */ var _actions_any__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./actions/any */ "./content/js/actions/any.js");
/* harmony import */ var _actions_indexPage__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./actions/indexPage */ "./content/js/actions/indexPage.js");
/* harmony import */ var _actions_aboutPage__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actions/aboutPage */ "./content/js/actions/aboutPage.js");
/* harmony import */ var _actions_contactPage__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./actions/contactPage */ "./content/js/actions/contactPage.js");
/* harmony import */ var _actions_blog__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./actions/blog */ "./content/js/actions/blog.js");
/* harmony import */ var _actions_blogPage__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./actions/blogPage */ "./content/js/actions/blogPage.js");
/* harmony import */ var _actions_blogArticle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./actions/blogArticle */ "./content/js/actions/blogArticle.js");










const CONFIG = {
  defaultTheme: 'dark',
  themeAttribute: 'data-theme',
  iconsBasePath: '/css/icons',
}

class Rule {
  constructor(name, condition, action, id) {
    this.name = name
    this.condition = condition
    this.action = action
    this.id = id
  }
  static genCondit(arr) {
    return path => {
      // NOTE: Sometimes, if the link has a doubleshlash, it fails these tests and the
      // site breaks! I didn't resolve this in the front-end because even if i did so,
      // it wouldn't solve the problem in its root: Why this whole thing depends on the url?
      return arr.some(str => {
        /*
        console.log(`Comparing: '${str}' with '${path}'`)
        console.log(
          `=> ${str === path} ||
            ${str === decodeURIComponent(path)} ||
            ${str === encodeURIComponent(path)}`
        )*/
        return (
          str === path ||
          str === decodeURIComponent(path) ||
          str === encodeURIComponent(path)
        )
      })
    }
  }
}

const rules = [
  new Rule('any', () => true, _actions_any__WEBPACK_IMPORTED_MODULE_1__["default"]),
  new Rule(
    'indexPage',
    Rule.genCondit(['/', '/index', '/index.html', 'index']),
    _actions_indexPage__WEBPACK_IMPORTED_MODULE_2__["default"],
    'index'
  ),
  new Rule(
    'aboutPage',
    Rule.genCondit(['/about.html', '/about', 'about']),
    _actions_aboutPage__WEBPACK_IMPORTED_MODULE_3__["default"],
    'about'
  ),
  new Rule(
    'contactPage',
    Rule.genCondit(['/contact.html', '/contact', 'contact']),
    _actions_contactPage__WEBPACK_IMPORTED_MODULE_4__["default"],
    'contact'
  ),
  new Rule('blog', path => path.includes('blog'), _actions_blog__WEBPACK_IMPORTED_MODULE_5__["default"]),
  new Rule(
    'blogPage',
    Rule.genCondit(['/blog.html', '/blog', 'blog']),
    _actions_blogPage__WEBPACK_IMPORTED_MODULE_6__["default"],
    'blog'
  ),
  new Rule(
    'article',
    path => {
      return (
        path.includes('blog') &&
        !Rule.genCondit(['/blog.html', '/blog', 'blog'])(path)
      )
    },
    _actions_blogArticle__WEBPACK_IMPORTED_MODULE_7__["default"],
    'article'
  ),
]

const main = (event, config) => {
  const status = event.type
  const pathname = window.location.pathname
  const matching = rules.filter(entry => {
    // console.log(entry.condition)
    return entry.condition(pathname)
  })
  const starterPack = {
    config: config,
    status: status,
    DOMContentLoaded: status === 'DOMContentLoaded',
    load: status === 'load',
    beforeunload: status === 'beforeunload',
    html: document.documentElement,
    head: document.head,
    body: document.body,
    preamble: document.getElementById('preamble'),
    topnav: document.getElementById('topnav'),
    content: document.getElementById('content'),
    postamble: document.getElementById('postamble'),
    footer: document.getElementsByTagName('footer')[0],
    log: console.log,
    err: console.error,
    matchedRulesList: matching,
    setActiveNavEntr: className => {
      const target = document.getElementsByClassName(className)[0]
      target.setAttribute('data-current', '')
    },
    openImageOn: event => {
      const url = event.target.getAttribute('src')
      window.open(url, '_blank').focus()
    },
  }
  matching.forEach(entry => {
    if (entry.name === 'any') return
    starterPack.entryName = entry.name || null
    entry.action(starterPack)
  })
  // 'any' should be called last
  matching.forEach(entry => {
    if (entry.name === 'any') {
      starterPack.entryName = 'any'
      entry.action(starterPack)
    }
  })

  // Initialize matomo
  ;(0,_matomoInit__WEBPACK_IMPORTED_MODULE_0__["default"])()
}

const mainCaller = event => {
  main(event, CONFIG)
}
window.addEventListener('DOMContentLoaded', mainCaller) // DOM loaded
window.addEventListener('load', mainCaller) // DOM + static loaded
window.addEventListener('beforeunload', mainCaller) // unloaded (pressing back, visiting link ...)

})();

// This entry need to be wrapped in an IIFE because it need to be isolated against other entry modules.
(() => {
/*!*********************************!*\
  !*** ./content/scss/style.scss ***!
  \*********************************/
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (__webpack_require__.p + "css/style.min.css");
})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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cGFjazovL3RoZXdlYm1hc3RlcnAuY29tLy4vY29udGVudC9qcy9hY3Rpb25zL2Fib3V0UGFnZS5qcyIsIndlYnBhY2s6Ly90aGV3ZWJtYXN0ZXJwLmNvbS8uL2NvbnRlbnQvanMvYWN0aW9ucy9hbnkuanMiLCJ3ZWJwYWNrOi8vdGhld2VibWFzdGVycC5jb20vLi9jb250ZW50L2pzL2FjdGlvbnMvYmxvZy5qcyIsIndlYnBhY2s6Ly90aGV3ZWJtYXN0ZXJwLmNvbS8uL2NvbnRlbnQvanMvYWN0aW9ucy9ibG9nQXJ0aWNsZS5qcyIsIndlYnBhY2s6Ly90aGV3ZWJtYXN0ZXJwLmNvbS8uL2NvbnRlbnQvanMvYWN0aW9ucy9ibG9nUGFnZS5qcyIsIndlYnBhY2s6Ly90aGV3ZWJtYXN0ZXJwLmNvbS8uL2NvbnRlbnQvanMvYWN0aW9ucy9jb250YWN0UGFnZS5qcyIsIndlYnBhY2s6Ly90aGV3ZWJtYXN0ZXJwLmNvbS8uL2NvbnRlbnQvanMvYWN0aW9ucy9pbmRleFBhZ2UuanMiLCJ3ZWJwYWNrOi8vdGhld2VibWFzdGVycC5jb20vLi9jb250ZW50L2pzL2NvbXBvbmVudHMvZm9vdGVyR2VuZXJhdG9yLmpzIiwid2VicGFjazovL3RoZXdlYm1hc3RlcnAuY29tLy4vY29udGVudC9qcy9jb21wb25lbnRzL3NvY2lhbE1lZGlhQm94R2VuZXJhdG9yLmpzIiwid2VicGFjazovL3RoZXdlYm1hc3RlcnAuY29tLy4vY29udGVudC9qcy9jb21wb25lbnRzL3RoZW1lQ2hhbmdlci5qcyIsIndlYnBhY2s6Ly90aGV3ZWJtYXN0ZXJwLmNvbS8uL2NvbnRlbnQvanMvbWF0b21vSW5pdC5qcyIsIndlYnBhY2s6Ly90aGV3ZWJtYXN0ZXJwLmNvbS8uL2NvbnRlbnQvanMvc2NyaXB0cy94bWwyanNvbi5qcyIsIndlYnBhY2s6Ly90aGV3ZWJtYXN0ZXJwLmNvbS93ZWJwYWNrL2Jvb3RzdHJhcCIsIndlYnBhY2s6Ly90aGV3ZWJtYXN0ZXJwLmNvbS93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vdGhld2VibWFzdGVycC5jb20vd2VicGFjay9ydW50aW1lL2dsb2JhbCIsIndlYnBhY2s6Ly90aGV3ZWJtYXN0ZXJwLmNvbS93ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kIiwid2VicGFjazovL3RoZXdlYm1hc3RlcnAuY29tL3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vdGhld2VibWFzdGVycC5jb20vd2VicGFjay9ydW50aW1lL3B1YmxpY1BhdGgiLCJ3ZWJwYWNrOi8vdGhld2VibWFzdGVycC5jb20vLi9jb250ZW50L2pzL2luZGV4LmpzIiwid2VicGFjazovL3RoZXdlYm1hc3RlcnAuY29tLy4vY29udGVudC9zY3NzL3N0eWxlLnNjc3MiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgYWJvdXRQYWdlID0gc3AgPT4ge1xuICBzcC5sb2coYCR7c3AuZW50cnlOYW1lfSAtICR7c3Auc3RhdHVzfWApXG4gIGlmIChzcC5ET01Db250ZW50TG9hZGVkKSB7XG4gICAgLy8gU2V0IHRoZSBhY3RpdmUgbmF2aWdhdGlvbiBlbnRyeVxuICAgIHNwLnNldEFjdGl2ZU5hdkVudHIoJ2Fib3V0TGluaycpXG5cbiAgICAvLyBHaXZlIHNvbWUgY3VzdG9tIHN0cnVjdHVyZSB0byBhYm91dG1lXG4gICAgY29uc3QgbWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWUnKVxuICAgIG1lLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCAoKSA9PiB7XG4gICAgICBjb25zdCB0ZXh0QWJvdXRtZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0ZXh0LWFib3V0bWUnKVxuICAgICAgY29uc3QgZmlndXJlID0gbWUucGFyZW50RWxlbWVudFxuICAgICAgY29uc3QgZmlndXJlSFRNTCA9IGZpZ3VyZS5jbG9uZU5vZGUodHJ1ZSkub3V0ZXJIVE1MXG4gICAgICBmaWd1cmUucmVtb3ZlKClcbiAgICAgIHRleHRBYm91dG1lLmlubmVySFRNTCA9IGAke2ZpZ3VyZUhUTUx9PGRpdj4ke3RleHRBYm91dG1lLmlubmVySFRNTH08L2Rpdj5gXG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbWUnKS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHNwLm9wZW5JbWFnZU9uKVxuICAgIH0pXG4gIH0gZWxzZSBpZiAoc3AubG9hZCkge1xuICB9IGVsc2UgaWYgKHNwLmJlZm9yZXVubG9hZCkge1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFib3V0UGFnZVxuIiwiaW1wb3J0IHRoZW1lQ2hhbmdlckJ0biBmcm9tICcuLi9jb21wb25lbnRzL3RoZW1lQ2hhbmdlcidcbmltcG9ydCBmb290ZXJHZW5lcmF0b3IgZnJvbSAnLi4vY29tcG9uZW50cy9mb290ZXJHZW5lcmF0b3InXG5pbXBvcnQgc29jaWFsTWVkaWFCb3hHZW5lcmF0b3IgZnJvbSAnLi4vY29tcG9uZW50cy9zb2NpYWxNZWRpYUJveEdlbmVyYXRvcidcblxuaW1wb3J0IHhtbDJqc29uIGZyb20gJy4uL3NjcmlwdHMveG1sMmpzb24nXG5cbmNvbnN0IGFueSA9IHNwID0+IHtcbiAgc3AubG9nKGAke3NwLmVudHJ5TmFtZX0gLSAke3NwLnN0YXR1c31gKVxuXG4gIC8vIEluaXRpYWxpemUgdGhlbWVcbiAgY29uc3QgYXR0ciA9IHNwLmNvbmZpZy50aGVtZUF0dHJpYnV0ZVxuICBsZXQgdGhlbWUgPSBsb2NhbFN0b3JhZ2UuZ2V0SXRlbShhdHRyKVxuICBpZiAoIXRoZW1lKSB7XG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oYXR0ciwgc3AuY29uZmlnLmRlZmF1bHRUaGVtZSlcbiAgICB0aGVtZSA9IHNwLmNvbmZpZy5kZWZhdWx0VGhlbWVcbiAgfVxuICBkb2N1bWVudD8uZG9jdW1lbnRFbGVtZW50Py5zZXRBdHRyaWJ1dGU/LihhdHRyLCB0aGVtZSlcbiAgd2luZG93Py5SRU1BUks0Mj8uY2hhbmdlVGhlbWU/Lih0aGVtZSlcbiAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgLy8gSnVzdCB0byBtYWtlIHN1cmVcbiAgICB3aW5kb3c/LlJFTUFSSzQyPy5jaGFuZ2VUaGVtZT8uKHRoZW1lKVxuICB9LCAxMDAwKVxuXG4gIGlmIChzcC5ET01Db250ZW50TG9hZGVkKSB7XG4gICAgLy8gQWRkIGEgY2xhc3Mgb2YgLnByZWxvYWQgdG8gdGhlIGJvZHkgKGFuZCB3aGVuIHRoZSB3aG9sZSBwYWdlIGlzIGxvYWRlZCAtIFJlbW92ZSBpdCkuXG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdwcmVsb2FkJylcblxuICAgIC8vIEFwcGx5IHRoZSBhcHByb3ByaWF0ZSBpZCB0byB0aGUgY3VycmVudCBwYWdlJ3MgYm9keVxuICAgIGNvbnN0IHdpdGhJZE9ubHkgPSBzcC5tYXRjaGVkUnVsZXNMaXN0LmZpbHRlcihlbnRyeSA9PiBlbnRyeS5pZClcbiAgICBpZiAoIXdpdGhJZE9ubHlbMF0pIHtcbiAgICAgIHNwLmVycignTm8gbWF0Y2hpbmcgcnVsZXMgZm9yIHRoZSBjdXJyZW50IHBhZ2UhJylcbiAgICB9XG4gICAgZG9jdW1lbnQuYm9keS5zZXRBdHRyaWJ1dGUoJ2lkJywgd2l0aElkT25seVswXT8uaWQgfHwgJ3VuZGVmaW5lZCcpXG5cbiAgICAvLyBFdmVyeSBsaW5rIHBvaW50aW5nIHRvIGFuIG91dHNpZGUgd2Vic2l0ZSBzaG91bGQgYmUgb3BlbmVkIGluIGEgbmV3IHRhYlxuICAgIC8vIEV2ZXJ5IGxpbmsgaHJlZiBzaG91bGQgYmUgZm9ybWF0dGVkIChJIHVuZGVyc3RhbmQgSlMgbW9yZSB0aGFuIGVsaXNwLi4uIHNyeSlcbiAgICBjb25zdCBjb250ZW50QW5jaG9ycyA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJylcbiAgICAvLyBOT1RFOiBJZiB5b3UgdXNlIGFueSBzcGVjaWFsIGNoYXJhY3RlcnMgbGlrZSAjIG9yIHN0aCBlbHNlIGluIHlvdXIgZmlsZW5hbWVzLCBsaXN0IHRoZW0gaGVyZS5cbiAgICBjb25zdCBzcGVjQ2hhciA9IFsnIyddXG4gICAgO1suLi5jb250ZW50QW5jaG9yc10uZm9yRWFjaChhID0+IHtcbiAgICAgIGNvbnN0IGhyZWYgPSBhLmdldEF0dHJpYnV0ZSgnaHJlZicpXG4gICAgICBpZiAoaHJlZi5zdGFydHNXaXRoKCdodHRwczovLycpIHx8IGhyZWYuc3RhcnRzV2l0aCgnaHR0cDovLycpKSB7XG4gICAgICAgIGEuc2V0QXR0cmlidXRlKCd0YXJnZXQnLCAnX2JsYW5rJylcbiAgICAgIH0gZWxzZSBpZiAoXG4gICAgICAgIGhyZWZcbiAgICAgICAgICAuc3Vic3RyaW5nKDEpXG4gICAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAgIC5zb21lKHN0ciA9PiBzcGVjQ2hhci5pbmNsdWRlcyhzdHIpKSB8fFxuICAgICAgICBkZWNvZGVVUklDb21wb25lbnQoaHJlZi5zdWJzdHJpbmcoMSkpXG4gICAgICAgICAgLnNwbGl0KCcnKVxuICAgICAgICAgIC5zb21lKHN0ciA9PiBzcGVjQ2hhci5pbmNsdWRlcyhzdHIpKVxuICAgICAgKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGhyZWYpXG4gICAgICAgIGNvbnN0IG5ld0hyZWYgPSBlbmNvZGVVUklDb21wb25lbnQoaHJlZilcbiAgICAgICAgYS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBuZXdIcmVmKVxuICAgICAgfVxuICAgIH0pXG5cbiAgICAvLyBBcHBlbmQgYSBDU1MgY2xhc3MgLmNsaWNrZWQgdG8gYSBjbGlja2VkIGFuY2hvciBmcm9tICN0b3BuYXZcbiAgICBjb25zdCB0b3BOYXZMaW5rcyA9IHNwLnRvcG5hdi5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpXG4gICAgO1suLi50b3BOYXZMaW5rc10uZm9yRWFjaChhID0+IHtcbiAgICAgIGEuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlID0+IHtcbiAgICAgICAgZS50YXJnZXQuY2xhc3NMaXN0LmFkZCgnY2xpY2tlZCcpXG4gICAgICB9KVxuICAgIH0pXG5cbiAgICAvLyBUaGVtZSBjaGFuZ2VyIGNvbnRyb2xzXG4gICAgY29uc3QgdGhlbVN3ckNvbnN0cnVjdGlvblNpdGVzID0gW1xuICAgICAgLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnRoZW1lLWNoYW5nZXInKSxcbiAgICBdXG4gICAgdGhlbVN3ckNvbnN0cnVjdGlvblNpdGVzLmZvckVhY2goc2l0ZSA9PiB7XG4gICAgICBjb25zdCBidG4gPSB0aGVtZUNoYW5nZXJCdG4oJ1RvZ2dsZSBiZXR3ZWVuIGRhcmsgYW5kIGxpZ2h0IG1vZGUnLCAoKSA9PiB7XG4gICAgICAgIC8vYnRuIG9uY2xpY2sgY2FsbGJhY2tcbiAgICAgICAgY29uc3QgYXR0ciA9IHNwLmNvbmZpZy50aGVtZUF0dHJpYnV0ZVxuICAgICAgICBjb25zdCBjdXJyVGhlbWVGcm9tQXR0ciA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoYXR0cilcbiAgICAgICAgY29uc3QgY3VyclRoZW1lRnJvbUxTdG9yYWdlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oYXR0cilcbiAgICAgICAgaWYgKGN1cnJUaGVtZUZyb21BdHRyICE9PSBjdXJyVGhlbWVGcm9tTFN0b3JhZ2UpXG4gICAgICAgICAgY29uc29sZS53YXJuKCdUaGVtZSBhdHRyaWJ1dGUgLSBMb2NhbCBzdG9yYWdlIGRpc21hdGNoIScpXG4gICAgICAgIGNvbnN0IGN1cnJlbnRUaGVtZSA9IGN1cnJUaGVtZUZyb21BdHRyXG4gICAgICAgIGlmIChjdXJyZW50VGhlbWUgPT09ICdsaWdodCcpIHtcbiAgICAgICAgICAvLyBTd2l0Y2ggdG8gZGFya1xuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGF0dHIsICdkYXJrJylcbiAgICAgICAgICBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHIsICdkYXJrJylcbiAgICAgICAgICB3aW5kb3c/LlJFTUFSSzQyPy5jaGFuZ2VUaGVtZT8uKCdkYXJrJylcbiAgICAgICAgfSBlbHNlIGlmIChjdXJyZW50VGhlbWUgPT09ICdkYXJrJykge1xuICAgICAgICAgIC8vIFN3aXRjaCB0byBsaWdodFxuICAgICAgICAgIGxvY2FsU3RvcmFnZS5zZXRJdGVtKGF0dHIsICdsaWdodCcpXG4gICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyLCAnbGlnaHQnKVxuICAgICAgICAgIHdpbmRvdz8uUkVNQVJLNDI/LmNoYW5nZVRoZW1lPy4oJ2xpZ2h0JylcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2l0ZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSA9PT0gJ3NwYXJzZScpIHtcbiAgICAgICAgICBzaXRlLmNsYXNzTGlzdC5hZGQoJ3RvcC1sZXZlbCcpXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgICBpZiAoc2l0ZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSA9PT0gJ3NwYXJzZScpIHtcbiAgICAgICAgc2l0ZS5jbGFzc0xpc3QuYWRkKCd0b3AtbGV2ZWwnKVxuICAgICAgfVxuICAgICAgc2l0ZS5hcHBlbmQoYnRuKVxuICAgIH0pXG5cbiAgICAvKlxuICAgIDtbLi4uZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLnRoZW1lLWNoYW5nZXIgPiBidXR0b24nKV0uZm9yRWFjaChidG4gPT4ge1xuICAgICAgYnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4ge1xuICAgICAgICAvL0ltcGxlbWVudCB0aGUgbG9jYWwgc3RvcmFnZSBhbmQgRE9NIHRvZ2dsZVxuICAgICAgICBzcC5sb2coJy50aGVtZS1jaGFuZ2VyIGJ1dHRvbiBjbGlja2VkJylcbiAgICAgICAgY29uc3QgY3VycmVudFRoZW1lID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmdldEF0dHJpYnV0ZShhdHRyKVxuICAgICAgICBpZiAoY3VycmVudFRoZW1lID09PSAnbGlnaHQnKSB7XG4gICAgICAgICAgLy8gU3dpdGNoIHRvIGRhcmtcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShhdHRyLCAnZGFyaycpXG4gICAgICAgICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNldEF0dHJpYnV0ZShhdHRyLCAnZGFyaycpXG4gICAgICAgICAgd2luZG93Py5SRU1BUks0Mj8uY2hhbmdlVGhlbWU/LignZGFyaycpXG4gICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFRoZW1lID09PSAnZGFyaycpIHtcbiAgICAgICAgICAvLyBTd2l0Y2ggdG8gbGlnaHRcbiAgICAgICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShhdHRyLCAnbGlnaHQnKVxuICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zZXRBdHRyaWJ1dGUoYXR0ciwgJ2xpZ2h0JylcbiAgICAgICAgICB3aW5kb3c/LlJFTUFSSzQyPy5jaGFuZ2VUaGVtZT8uKCdsaWdodCcpXG4gICAgICAgIH0gXG5cbiAgICAgICAgLy8gQWRkIHNvbWUgY29vbCBzdHlsaW5nIHRvIHRoZSBidXR0b24gaXRzZWxmIHRvIGluZGljYXRlIHRoZW1lXG4gICAgICB9KVxuICAgIH0pKi9cblxuICAgIC8vIEV2ZXJ5IGltYWdlIGluICNjb250ZW50LCBvbiBjbGljayBzaG91bGQgYmUgb3BlbmVkIGluIGEgbmV3IHRhYi5cbiAgICBjb25zdCBpbWdzID0gc3AuY29udGVudD8uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2ltZycpXG4gICAgO1suLi5pbWdzXS5mb3JFYWNoKGltZyA9PiB7XG4gICAgICBpbWcuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBzcC5vcGVuSW1hZ2VPbilcbiAgICB9KVxuICB9IGVsc2UgaWYgKHNwLmxvYWQpIHtcbiAgICAvLyBSZW1vdmUgdGhlIGNsYXNzIG9mIC5wcmVsb2FkIG9mIHRoZSBib2R5IHdoZW4gdGhlIHdob2xlIHBhZ2UncyBsb2FkZWQuXG4gICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QucmVtb3ZlKCdwcmVsb2FkJylcblxuICAgIC8vIFJlbW92ZSB0aGUgY29sb24gYXQgdGhlIGVuZCBvZiBjb2RlIGxpbmUgbnVtYmVyXG4gICAgO1suLi5kb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdsaW5lbnInKV0uZm9yRWFjaChsaW5lID0+IHtcbiAgICAgIGxpbmUuaW5uZXJIVE1MID0gbGluZS5pbm5lckhUTUwuc2xpY2UoMCwgLTIpLmNvbmNhdCgnICcpXG4gICAgfSlcblxuICAgIC8vTWFrZSB0aGUgZm9vdGVyXG4gICAgY29uc3QgZm9vdGVyID0gZm9vdGVyR2VuZXJhdG9yKFxuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bvc3RhbWJsZScpLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd4bWwnKVswXVxuICAgIClcbiAgICAvL3Bvc3RhbWJsZS5pbm5lckhUTUwgKz0gZm9vdGVyLm91dGVySFRNTFxuICAgIHBvc3RhbWJsZS5hcHBlbmRDaGlsZChmb290ZXIpXG5cbiAgICAvLyBQcm9jZXNzIC5zb2NNZWRpYUJveFxuICAgIGNvbnN0IHNvY01lZGlhQm94ZXMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdzb2NNZWRpYUJveCcpXG4gICAgO1suLi5zb2NNZWRpYUJveGVzXS5mb3JFYWNoKHNvY01lZGlhQm94ID0+IHtcbiAgICAgIGNvbnN0IHhtbCA9IHNvY01lZGlhQm94LmdldEVsZW1lbnRzQnlUYWdOYW1lKCd4bWwnKVswXVxuICAgICAgaWYgKHhtbCkge1xuICAgICAgICBjb25zdCBqc29uID0geG1sMmpzb24oeG1sKVxuICAgICAgICBzb2NNZWRpYUJveC5pbm5lckhUTUwgPSBzb2NpYWxNZWRpYUJveEdlbmVyYXRvcihcbiAgICAgICAgICBqc29uWydTT0NNRURJQSddWydFTlRSWSddLFxuICAgICAgICAgIHNwLmNvbmZpZy5pY29uc0Jhc2VQYXRoXG4gICAgICAgICkub3V0ZXJIVE1MXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdtaXNzaW5nIHhtbCBpbiAuc29jTWVkaWFCb3ghJylcbiAgICAgIH1cbiAgICB9KVxuICB9IGVsc2UgaWYgKHNwLmJlZm9yZXVubG9hZCkge1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGFueVxuIiwiY29uc3QgYmxvZyA9IHNwID0+IHtcbiAgc3AubG9nKGAke3NwLmVudHJ5TmFtZX0gLSAke3NwLnN0YXR1c31gKVxuICBpZiAoc3AuRE9NQ29udGVudExvYWRlZCkge1xuICAgIC8vIFNldCB0aGUgYWN0aXZlIG5hdmlnYXRpb24gZW50cnlcbiAgICBzcC5zZXRBY3RpdmVOYXZFbnRyKCdibG9nTGluaycpXG4gIH0gZWxzZSBpZiAoc3AubG9hZCkge1xuICB9IGVsc2UgaWYgKHNwLmJlZm9yZXVubG9hZCkge1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IGJsb2dcbiIsImNvbnN0IGJsb2dBcnRpY2xlID0gc3AgPT4ge1xuICBzcC5sb2coYCR7c3AuZW50cnlOYW1lfSAtICR7c3Auc3RhdHVzfWApXG4gIGlmIChzcC5ET01Db250ZW50TG9hZGVkKSB7XG4gICAgLy8gR2V0IGRhdGUgcGFzc2VkIHRocm91Z2ggYW4gaHRtbCBjb21tZW50IGluc2lkZSA8aGVhZD5cbiAgICBjb25zdCBkYXRlID0gZG9jdW1lbnQuaGVhZC5pbm5lckhUTUxcbiAgICAgIC5zcGxpdCgnXFxuJylbMV1cbiAgICAgIC5yZXBsYWNlKC88IS0tIHwgLS0+L2csICcnKVxuXG4gICAgLy8gR2V0IGF1dGhvciBhbmQgZGVzY3JpcHRpb24gZnJvbSBzb21lIDxtZXRhPnMgaW4gPGhlYWQ+XG4gICAgY29uc3QgYXV0aG9yID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiYXV0aG9yXCJdJykuY29udGVudFxuICAgIGNvbnN0IGRlc2NyaXB0aW9uID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignbWV0YVtuYW1lPVwiZGVzY3JpcHRpb25cIl0nKVxuICAgICAgLmNvbnRlbnRcblxuICAgIC8vIFN0cnVjdHVyZSB0aGUgZmV0Y2hlZCBtZXRhZGF0YSB0byBiZSBpbnNlcnRlZCBvbiB0aGUgcmlnaHQgcGxhY2VcbiAgICBjb25zdCBtZXRhID0gYCA8ZGl2IGlkPVwiQXJ0aWNsZU1ldGFEYXRhXCI+XG5MYXN0IGNoYW5nZTogJHtkYXRlfTxicj5cbkF1dGhvcjogPGEgaHJlZj1cIi9hYm91dC5odG1sXCI+JHthdXRob3J9PC9hPlxuPC9kaXY+YFxuICAgIGNvbnN0IGRlc2NyaXB0aW9uSFRNTCA9IGA8cCBpZD1cImRlc2NyaXB0aW9uXCI+JHtkZXNjcmlwdGlvbn08L3A+YFxuXG4gICAgLy8gSW5zZXJ0IHRoZSBtZXRhZGF0YVxuICAgIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50XG4gICAgICAuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRlbnQnKVxuICAgICAgLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkZXInKVswXVxuICAgIGhlYWRlci5pbm5lckhUTUwgPSBoZWFkZXIuaW5uZXJIVE1MICsgbWV0YSArIGRlc2NyaXB0aW9uSFRNTFxuICB9IGVsc2UgaWYgKHNwLmxvYWQpIHtcbiAgfSBlbHNlIGlmIChzcC5iZWZvcmV1bmxvYWQpIHtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBibG9nQXJ0aWNsZVxuIiwiY29uc3QgYmxvZ1BhZ2UgPSBzcCA9PiB7XG4gIHNwLmxvZyhgJHtzcC5lbnRyeU5hbWV9IC0gJHtzcC5zdGF0dXN9YClcbiAgaWYgKHNwLkRPTUNvbnRlbnRMb2FkZWQpIHtcbiAgICAvLyBSZXBsYWNlIGRlZmF1bHQgc2VjdGlvbiBoZWFkaW5ncyAoYXJjaC8ganMvIGZvciBleGFtcGxlKSB3aXRoIGN1c3RvbSBvbmVzXG4gICAgY29uc3QgbWFwVG8gPSB7XG4gICAgICAnRGVza3RvcCBTZXR1cC8nOiB7XG4gICAgICAgIHRpdGxlOiAnT3B0aW1pemluZyB5b3VyIExpbnV4IGRlc2t0b3Agc2V0dXAgZm9yIHByb2dyYW1taW5nJyxcbiAgICAgICAgZGVzY3JpcHRpb246XG4gICAgICAgICAgJ0xldCB0aGUgYXJ0aWNsZXMgdW5kZXIgdGhpcyBzZWN0aW9uIGJlIGEgY29tcGVuZGl1bSAtIEFuIGVzc2VuY2Ugb2YgbXkgaGFyZC1sZWFybmVkIGxlc3NvbnMgcmVnYXJkaW5nIExpbnV4IGFuZCBpdHMgY29uZmlndXJhdGlvbiBhcyBhIG1heGltdW0gcHJvZHVjdGl2aXR5LCBwcm9ncmFtbWluZyBkZXNrdG9wIE9TLicsXG4gICAgICB9LFxuICAgICAgJ3dlYm1hc3Rlcl9wcm9qZWN0Lyc6IHtcbiAgICAgICAgdGl0bGU6ICdNYXN0ZXIgSmF2YVNjcmlwdCcsXG4gICAgICAgIGRlc2NyaXB0aW9uOlxuICAgICAgICAgIFwiRXZlcnkgSmF2YVNjcmlwdCB0aGluZyB0aGF0IGdvdCBteSBpbnRlcmVzdCBhbmQgaW5zcGlyZWQgbWUsIEknbGwgd3JpdGUgYSBwb3N0IGFib3V0IGl0IGFuZCBpdCB3aWxsIGJlIGxpc3RlZCBoZXJlLlwiLFxuICAgICAgfSxcbiAgICB9XG4gICAgLy8gRG8gaXRcbiAgICBjb25zdCBlbnRyaWVzID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnI2VudHJpZXMgPiB1bCA+IGxpJylcbiAgICBlbnRyaWVzLmZvckVhY2gobGkgPT4ge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gbGkuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2InKVswXVxuICAgICAgY29uc3QgaW5UYXJnZXQgPSB0YXJnZXQudGV4dENvbnRlbnRcbiAgICAgIE9iamVjdC5rZXlzKG1hcFRvKS5mb3JFYWNoKGtleSA9PiB7XG4gICAgICAgIGlmIChpblRhcmdldCA9PT0ga2V5KSB7XG4gICAgICAgICAgY29uc3QgdG9SZXBsYWNlVGFyZ2V0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgICBjb25zdCB0aXRsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2gzJylcbiAgICAgICAgICB0aXRsZS50ZXh0Q29udGVudCA9IG1hcFRvW2tleV0udGl0bGVcbiAgICAgICAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKVxuICAgICAgICAgIGRlc2NyaXB0aW9uLnRleHRDb250ZW50ID0gbWFwVG9ba2V5XS5kZXNjcmlwdGlvblxuICAgICAgICAgIGNvbnN0IGRlc2NyaXB0aW9uV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3VsJylcbiAgICAgICAgICBkZXNjcmlwdGlvbldyYXBwZXIuYXBwZW5kQ2hpbGQoZGVzY3JpcHRpb24pXG4gICAgICAgICAgdG9SZXBsYWNlVGFyZ2V0LmFwcGVuZCh0aXRsZSwgZGVzY3JpcHRpb25XcmFwcGVyKVxuICAgICAgICAgIHRhcmdldC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0b1JlcGxhY2VUYXJnZXQsIHRhcmdldClcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICB9KVxuICB9IGVsc2UgaWYgKHNwLmxvYWQpIHtcbiAgfSBlbHNlIGlmIChzcC5iZWZvcmV1bmxvYWQpIHtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBibG9nUGFnZVxuIiwiY29uc3QgY29udGFjdFBhZ2UgPSBzcCA9PiB7XG4gIHNwLmxvZyhgJHtzcC5lbnRyeU5hbWV9IC0gJHtzcC5zdGF0dXN9YClcbiAgaWYgKHNwLkRPTUNvbnRlbnRMb2FkZWQpIHtcbiAgICBjb25zdCBjb250YWN0bWUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGFjdG1lJylcbiAgICBpZiAoIWNvbnRhY3RtZSkgY29uc29sZS5lcnJvcignTm8gI2NvbnRhY3RtZSEnKVxuICAgIGNvbnRhY3RtZS5hZGRFdmVudExpc3RlbmVyKCdzdWJtaXQnLCAoKSA9PiB7XG4gICAgICBjb25zdCBzdWJqZWN0ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3N1YmplY3QnKVxuICAgICAgY29uc3QgYWN0aW9uID0gY29udGFjdG1lLmdldEF0dHJpYnV0ZSgnYWN0aW9uJylcbiAgICAgIGNvbnN0IHN1YmplY3RQcmVmaXggPSAnP3N1YmplY3Q9J1xuICAgICAgY29uc3QgaSA9IGFjdGlvbi5pbmRleE9mKHN1YmplY3RQcmVmaXgpICsgc3ViamVjdFByZWZpeC5sZW5ndGhcbiAgICAgIGNvbnRhY3RtZS5zZXRBdHRyaWJ1dGUoJ2FjdGlvbicsIGFjdGlvbi5zbGljZSgwLCBpKSArIHN1YmplY3QudmFsdWUpXG4gICAgICBjb25zb2xlLmxvZyhzdWJqZWN0LnZhbHVlKVxuICAgIH0pXG5cbiAgICBjb25zdCBncmVldGluZyA9ICdIZXkgdGhld2VibWFzdGVycCwgaGVhciB0aGlzIGpva2UuICdcbiAgICBjb25zdCBqb2tlcyA9IFtcbiAgICAgIFwiV2hhdCBhcmUgYSBzaGFyaydzIHR3byBtb3N0IGZhdm9yaXRlIHdvcmRzP1wiLCAvLyBNYW4gb3ZlcmJvYXJkIVxuICAgICAgJ1doeSBhcmUgZ2hvc3RzIHN1Y2ggYmFkIGxpYXJzPycsIC8vIEJlY2F1c2UgdGhleSBhcmUgZWFzeSB0byBzZWUgdGhyb3VnaC5cbiAgICAgICdXaGF0IGRvIHlvdSBjYWxsIGEgc2luZ2luZyBsYXB0b3A/JywgLy8gQSBEZWxsIVxuICAgICAgJ1doYXQgZGlkIHRoZSBidWZmYWxvIHNheSB3aGVuIGhpcyBzb24gbGVmdCBmb3IgY29sbGVnZT8nLCAvLyBCaXNvbiFcbiAgICAgICdXaHkgZGlkIHRoZSB3ZWIgZGV2ZWxvcGVyIGRyb3duPycsIC8vIEhlIGhhZCB0b28gbWFueSBhbmNob3JzLlxuICAgICAgJ1doeSB3YXMgdGhlIEphdmFTY3JpcHQgcmVhbGl0eSBzaG93IGNhbmNlbGxlZCBhZnRlciBvbmx5IG9uZSBlcGlzb2RlPycsIC8vIFBlb3BsZSB0aG91Z2h0IGl0IHNlZW1lZCBzY3JpcHRlZC5cbiAgICAgICdIb3cgY2FuIHlvdSB0ZWxsIHRoYXQgYSB3ZWIgZGV2ZWxvcGVyIGlzIHdvcmtpbmc/JywgLy8gWW91IGNhbiBoZWFyIGhpbSBHcnVudGluZyFcbiAgICAgICdXaHkgZG9lcyBubyBvbmUgbGlrZSBqb2tlcyBhYm91dCBkZXNjcmlwdGlvbnMsIGtleXdvcmRzLCBvciBjaGFyYWN0ZXIgZW5jb2RpbmdzPycsIC8vIFRoZXnigJlyZSB0b28g4oCYbWV0YeKAmS5cbiAgICAgICdXaHkgZGlkIHRoZSBJUCBjcm9zcyB0aGUgc3VibmV0PycsIC8vIEJlY2F1c2UgdGhlIE5BVCBzYWlkIHRvIVxuICAgICAgJ1doeSB3YXMgdGhlIGNsYXNzIHVwc2V0IHRoYXQgaXRzIHBhcmVudCBkaWVkPycsIC8vIEJlY2F1c2UgaXQgd291bGRu4oCZdCBiZSBnZXR0aW5nIHRoZSBpbmhlcml0YW5jZSFcbiAgICAgICdIb3cgZG8geW91IGNvbWZvcnQgYSBKYXZhU2NyaXB0IGJ1Zz8nLCAvLyBZb3UgY29uc29sZSBpdC5cbiAgICAgICdXaHkgd2FzIHRoZSB3ZWIgZGV2ZWxvcGVyIGZpcmVkIGZyb20gaGVyIGpvYj8nLCAvLyBTaGUgZGlkIExlc3MgZXZlcnkgZGF5LlxuICAgICAgJ0hvdyBkb2VzIGEgd2ViIGRldmVsb3BlciBsaWtlIGhpcyBjb2ZmZWU/JywgLy8gIzAwMDAwMFxuICAgICAgJ1doeSBkaWQgdGhlIHdlYiBkZXZlbG9wZXIgc2VuZCBhIGZldyBleHRyYSBidWNrcyB0byBoZXIgaG9zdGluZyBwcm92aWRlcj8nLCAvLyBCZWNhdXNlIHNoZSBoZWFyZCB0aGF0IHNoZSBzaG91bGQgYWx3YXlzIHRpcCBoZXIgc2VydmVyLlxuICAgICAgJ1doeSBjb3VsZG7igJl0IHRoZSBwcm9ncmFtbWVyIHdvcmsgbGF0ZSBpbnRvIHRoZSBuaWdodD8nLCAvLyBTaGUgZGlkbuKAmXQgaGF2ZSBhIExBTVAuXG4gICAgXS5tYXAoam9rZSA9PiBgJHtncmVldGluZ30ke2pva2V9YClcblxuICAgIGNvbnN0IHByb3AgPSAnYWxyZWFkeVNlZW5Kb2tlcydcbiAgICBsZXQgYWxyZWFkeVNlZW4gPSBKU09OLnBhcnNlKGxvY2FsU3RvcmFnZS5nZXRJdGVtKHByb3ApKSB8fCBbXVxuICAgIGlmIChhbHJlYWR5U2Vlbi5sZW5ndGggPT09IGpva2VzLmxlbmd0aCkge1xuICAgICAgLy8gSWYgYWxsIGpva2VzIHNlZW4sIHJlc2V0IHRoZSB0cmFja2VyXG4gICAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShwcm9wLCBKU09OLnN0cmluZ2lmeShbXSkpXG4gICAgICBhbHJlYWR5U2VlbiA9IEpTT04ucGFyc2UobG9jYWxTdG9yYWdlLmdldEl0ZW0ocHJvcCkpXG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgYWxyZWFkeSBzZWVuIGpva2VzXG4gICAgYWxyZWFkeVNlZW4uZm9yRWFjaChuID0+IHtcbiAgICAgIGpva2VzLnNwbGljZShuLCAxKVxuICAgIH0pXG4gICAgY29uc3QgcmFuZG9tSm9rZUluZGV4ID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogam9rZXMubGVuZ3RoKVxuICAgIGNvbnN0IG5ld0FscmVhZHlTZWVuID0gSlNPTi5wYXJzZShsb2NhbFN0b3JhZ2UuZ2V0SXRlbShwcm9wKSkgfHwgW11cbiAgICBuZXdBbHJlYWR5U2Vlbi5wdXNoKHJhbmRvbUpva2VJbmRleClcbiAgICBsb2NhbFN0b3JhZ2Uuc2V0SXRlbShwcm9wLCBKU09OLnN0cmluZ2lmeShuZXdBbHJlYWR5U2VlbikpXG5cbiAgICAvLyBBcHBseSB0aGUgY2hvc2VuIGpva2UgYXMgYSBwbGFjZWhvbGRlciBmb3IgdGhlIG1lc3NhZ2VcbiAgICBkb2N1bWVudFxuICAgICAgLmdldEVsZW1lbnRCeUlkKCdtZXNzYWdlJylcbiAgICAgIC5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgam9rZXNbcmFuZG9tSm9rZUluZGV4XSlcbiAgfSBlbHNlIGlmIChzcC5sb2FkKSB7XG4gIH0gZWxzZSBpZiAoc3AuYmVmb3JldW5sb2FkKSB7XG4gIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY29udGFjdFBhZ2VcbiIsImNvbnN0IGluZGV4UGFnZSA9IHNwID0+IHtcbiAgc3AubG9nKGAke3NwLmVudHJ5TmFtZX0gLSAke3NwLnN0YXR1c31gKVxuXG4gIC8vIFdlbGNvbWUgdGhlIHVzZXIgd2l0aCBhIG5pY2UgZmFsbGluZy1mcm9tLXRoZS1za3kgbWVzc2FnZVxuICBjb25zdCB3ZWxjb21lVXMgPSAoKSA9PiB7XG4gICAgY29uc3Qgd2VsY29tZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd3ZWxjb21lJylcbiAgICBjb25zdCBwZ3cgPSB3aW5kb3cuaW5uZXJXaWR0aFxuICAgIHdlbGNvbWUuc3R5bGUuYm90dG9tID0gcGd3IDwgNTUwID8gJzVlbScgOiAnNGVtJ1xuICAgIHdlbGNvbWUuc3R5bGUub3BhY2l0eSA9ICcxJ1xuICAgIHJldHVybiB3ZWxjb21lVXMgLy9SZXR1cm5zIGl0c2VsZiAobmVlZGVkIGZvciBhZGRFdmVudExpc3RlbmVyIGluIHRoaXMgY2FzZSlcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIGluZGV4IHBhZ2UgaXMgcmVsb2FkZWQsIGl0cyBzY3JvbGwgc2hvdWxkIGFsd2F5cyBzdGFydCBmcm9tIHRvcC4gRWxzZSwgdGhlcmUncyBhIGJ1ZyB3aXRoIHRoZSAjbWFzay5cbiAgaWYgKCdzY3JvbGxSZXN0b3JhdGlvbicgaW4gaGlzdG9yeSkge1xuICAgIGhpc3Rvcnkuc2Nyb2xsUmVzdG9yYXRpb24gPSAnbWFudWFsJ1xuICB9XG5cbiAgaWYgKHNwLkRPTUNvbnRlbnRMb2FkZWQpIHtcbiAgICAvLyBTZXQgdGhlIGFjdGl2ZSBuYXZpZ2F0aW9uIGVudHJ5XG4gICAgc3Auc2V0QWN0aXZlTmF2RW50cignaG9tZUxpbmsnKVxuXG4gICAgLy8gUGFycmFsYXhcblxuICAgIC8vIFVuaXRlICNwcmVhbWJsZSwgI2NvbnRlbnQgYW5kICNwb3N0YW1ibGUgXCJ1bmRlciB0aGUgZmxhZ1wiIG9mICNwcmVDb25Qb3NXcmFwcGVyXG4gICAgY29uc3QgcHJlYW1ibGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJlYW1ibGUnKS5jbG9uZU5vZGUodHJ1ZSlcbiAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2NvbnRlbnQnKS5jbG9uZU5vZGUodHJ1ZSlcbiAgICBjb25zdCBwb3N0YW1ibGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncG9zdGFtYmxlJykuY2xvbmVOb2RlKHRydWUpXG4gICAgY29uc3QgcHJlQ29uUG9zV3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgcHJlQ29uUG9zV3JhcHBlci5zZXRBdHRyaWJ1dGUoJ2lkJywgJ3ByZUNvblBvc1dyYXBwZXInKVxuICAgIC8vIFNvbWUgaW5zaWduaWZpY2FudCBib3hlcyB3aXRoIGdyYWRpZW50IC8gZmlsbC5cbiAgICBjb25zdCBib3hlcyA9IG5ldyBBcnJheSg0KS5maWxsKCcnKS5tYXAoKGJveCwgaSkgPT4ge1xuICAgICAgYm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIGJveC5jbGFzc05hbWUgPSAnZmFrZUJnJ1xuICAgICAgYm94LmlkID0gYGZha2VCZy0ke2kgKyAxfWBcbiAgICAgIGNvbnN0IGZpbGxzID0gbmV3IEFycmF5KDIpLmZpbGwoJycpLm1hcCgoZmlsbCwgaSkgPT4ge1xuICAgICAgICBmaWxsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgZmlsbC5jbGFzc05hbWUgPSBgZmlsbC0ke2kgKyAxfWBcbiAgICAgICAgcmV0dXJuIGZpbGxcbiAgICAgIH0pXG4gICAgICBib3guYXBwZW5kKC4uLmZpbGxzKVxuICAgICAgcmV0dXJuIGJveFxuICAgIH0pXG4gICAgcHJlQ29uUG9zV3JhcHBlci5hcHBlbmQocHJlYW1ibGUsIGNvbnRlbnQsIHBvc3RhbWJsZSwgLi4uYm94ZXMpXG5cbiAgICBsZXQgcGFyYWxsYXhMYXllcnMgPSBuZXcgQXJyYXkoNikuZmlsbCgnJykubWFwKHN0ciA9PiAoe30pKVxuICAgIHBhcmFsbGF4TGF5ZXJzLmZvckVhY2goKHByb3RvLCBpKSA9PiB7XG4gICAgICBwcm90by5jbGFzc0xpc3QgPSBbXVxuICAgICAgcHJvdG8uY2xhc3NMaXN0LnB1c2goJ2xheWVyJywgYGxheWVyLSR7aX1gKVxuICAgIH0pXG4gICAgcGFyYWxsYXhMYXllcnMgPSBwYXJhbGxheExheWVycy5tYXAoKHByb3RvLCBpLCBhcnIpID0+IHtcbiAgICAgIGNvbnN0IGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoLi4ucHJvdG8uY2xhc3NMaXN0KVxuXG4gICAgICBsZXQgY29udGVudCA9ICcnXG4gICAgICBpZiAoaSA9PT0gYXJyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgLy8gSWYgaXQgaXMgdGhlIGxhc3QgZWxlbWVudCBhZGQgbWFpbiBjb250ZW50IHRvIGl0XG4gICAgICAgIGNvbnRlbnQgPSBwcmVDb25Qb3NXcmFwcGVyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBFbHNlLCBpdCBpcyBhIGZyYW1lIG9mIHRoZSBwYXJhbGxheFxuICAgICAgICAvLyBDcmVhdGUgYSBzdWItZWxlbWVudCB3aGljaCBob2xkcyBwYXJhbGxheCBmcmFtZSBiYWNrZ3JvdW5kXG4gICAgICAgIGNvbnN0IGltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIGltZy5jbGFzc0xpc3QuYWRkKCdpbWcnKVxuICAgICAgICBjb250ZW50ID0gaW1nXG4gICAgICAgIC8qXG5cdFx0ICogRGVwcmVjYXRlZCFcblx0XHQgKiBDaGFuZ2luZyBlbGVtZW50IGNsYXNzIGV2ZXJ5IGZldyBtaWxsaXNlY29uZHMgdHJpZ2dlcnMgYSBET00gcmUtcmVuZGVyXG5cdFx0ICogd2hpY2ggaXMgY2F1c2luZyB0aGlzIGNob3BwaW5lc3MuXG5cdFx0ICogXG4gICAgICAgIGlmIChwcm90by50b2dnbGVDbGFzc2VzPy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIC8vIFBpY2sgYSByYW5kb20gc3RyaW5nIGZyb20gdGhlIGFyciBhbmQgYXBwbHkgaXQgdG8gdGhlIC5pbWcgaW4gcmFuZG9tIGludGVydmFsc1xuICAgICAgICAgIGNvbnN0IHJhbmRDbGFzc09uUmFuZEludGVydmFsID0gKFxuICAgICAgICAgICAgZWwsXG4gICAgICAgICAgICBhcnIsXG4gICAgICAgICAgICBtaW4gPSAyMDAsXG4gICAgICAgICAgICBtYXggPSA2MDAsXG4gICAgICAgICAgICBwcmV2XG4gICAgICAgICAgKSA9PiB7XG4gICAgICAgICAgICBsZXQgcmFuZENsYXNzXG4gICAgICAgICAgICAvL01ha2Ugc3VyZSB0aGUgcmFuZENsYXNzIGlzIG5vdCB0aGUgc2FtZSBhcyB0aGUgb2xkIG9uZS5cbiAgICAgICAgICAgIGRvIHtcbiAgICAgICAgICAgICAgcmFuZENsYXNzID0gYXJyW01hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGFyci5sZW5ndGgpXVxuICAgICAgICAgICAgfSB3aGlsZSAocmFuZENsYXNzID09PSBwcmV2KVxuXG4gICAgICAgICAgICBjb25zdCByYW5kSW50ZXJ2YWwgPSBNYXRoLmZsb29yKFxuICAgICAgICAgICAgICBNYXRoLnJhbmRvbSgpICogKG1heCAtIG1pbiArIDEpICsgbWluXG4gICAgICAgICAgICApXG4gICAgICAgICAgICBpZiAocHJldikge1xuICAgICAgICAgICAgICAvLyBDbGVhbiB1cFxuICAgICAgICAgICAgICBlbC5jbGFzc0xpc3QucmVtb3ZlKHByZXYpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbC5jbGFzc0xpc3QuYWRkKHJhbmRDbGFzcylcbiAgICAgICAgICAgIHNldFRpbWVvdXQoXG4gICAgICAgICAgICAgIHJhbmRDbGFzc09uUmFuZEludGVydmFsLFxuICAgICAgICAgICAgICByYW5kSW50ZXJ2YWwsXG4gICAgICAgICAgICAgIGltZyxcbiAgICAgICAgICAgICAgYXJyLFxuICAgICAgICAgICAgICBtaW4sXG4gICAgICAgICAgICAgIG1heCxcbiAgICAgICAgICAgICAgcmFuZENsYXNzXG4gICAgICAgICAgICApXG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIEFsbCB0aGF0IG5lZWRzIG11bHRpcGxlIGZyYW1lcywgc2V0IHVwIGluZGl2aWR1YWwgc2V0dGluZ3MgaGVyZVxuICAgICAgICAgIGlmIChwcm90by50b2dnbGVDbGFzc2VzLmluY2x1ZGVzKCdoYW5kczEnKSkge1xuICAgICAgICAgICAgLy8gVG9nZ2xlIHRoZSBoYW5kc1xuICAgICAgICAgICAgcmFuZENsYXNzT25SYW5kSW50ZXJ2YWwoaW1nLCBwcm90by50b2dnbGVDbGFzc2VzLCAxNTAsIDIwMClcbiAgICAgICAgICB9IGVsc2UgaWYgKHByb3RvLnRvZ2dsZUNsYXNzZXMuaW5jbHVkZXMoJ2V5ZXMxJykpIHtcbiAgICAgICAgICAgIC8vIFRvZ2dsZSB0aGUgZXllc1xuICAgICAgICAgICAgcmFuZENsYXNzT25SYW5kSW50ZXJ2YWwoaW1nLCBwcm90by50b2dnbGVDbGFzc2VzLCA1MCwgMTAwMClcbiAgICAgICAgICB9XG4gICAgICAgIH0gKi9cbiAgICAgIH1cbiAgICAgIGVsLmFwcGVuZChjb250ZW50KVxuXG4gICAgICByZXR1cm4gZWxcbiAgICB9KVxuXG4gICAgLy8gQ3JlYXRlIHRoZSAjcGFyYWxsYXhcbiAgICBjb25zdCBwYXJhbGxheCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgcGFyYWxsYXguc2V0QXR0cmlidXRlKCdpZCcsICdwYXJhbGxheCcpXG4gICAgcGFyYWxsYXguYXBwZW5kKC4uLnBhcmFsbGF4TGF5ZXJzKVxuXG4gICAgLy8gRGV2YXN0YXRlIGFuZCByZWNyZWF0ZSB0aGUgPGJvZHk+XG4gICAgZG9jdW1lbnQuYm9keS5pbm5lckhUTUwgPSAnJ1xuICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQocGFyYWxsYXgpXG5cbiAgICAvLyAyLiBHcmVldGluZ1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIHdlbGNvbWVVcygpLCB0cnVlKSAvL05vdCBhIHR5cG86IENhbGwgd2VsY29tZVVzIGluaXRpYWxseSBhbmQgdGhlbiBvbiByZXNpemUuIChOb3RpY2UgdGhhdCB3ZWxjb21lVXMgcmV0dXJucyBpdHNlbGYpXG4gICAgfSwgMTUwKVxuICB9IGVsc2UgaWYgKHNwLmxvYWQpIHtcbiAgfSBlbHNlIGlmIChzcC5iZWZvcmV1bmxvYWQpIHtcbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBpbmRleFBhZ2VcbiIsImltcG9ydCB4bWwyanNvbiBmcm9tICcuLi9zY3JpcHRzL3htbDJqc29uJ1xuXG5jb25zdCBmb290ZXJHZW5lcmF0b3IgPSB4bWwgPT4ge1xuICBjb25zdCBqc29uID0geG1sMmpzb24oeG1sKVxuXG4gIC8vIFNvY2lhbE1lZGlhXG4gIGNvbnN0IHNvY21lZGlhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgc29jbWVkaWEuaWQgPSAnc29jbWVkaWEnXG4gIGNvbnN0IHNvY2lhbE1lZGlhQm94ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgc29jaWFsTWVkaWFCb3guY2xhc3NOYW1lID0gJ3NvY01lZGlhQm94J1xuICBzb2NpYWxNZWRpYUJveC5pbm5lckhUTUwgPSBgPHhtbD4ke1xuICAgIHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc29jbWVkaWEnKVswXS5vdXRlckhUTUxcbiAgfTwveG1sPmAgLy8gVGhlIHhtbCB3aWxsIGxhdGVyIGJlIHJlcGxhY2VkLiBMb29rIGF0IGFjdGlvbiBhbnkuanNcbiAgc29jbWVkaWEuYXBwZW5kKHNvY2lhbE1lZGlhQm94KVxuXG4gIC8vIFN1YnNjcmliZSAoTk9URTogRm9yIG5vdyB0aGlzIGNvbXBvbmVudCBpcyBub3QgbmVlZGVkLCB0aGVyZWZvcmUgaXQgd29uJ3QgYmUgZGlzcGxheWVkKVxuICAvKlxuICBjb25zdCBzdWJzY3JpYmUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBzdWJzY3JpYmUuaWQgPSAnc3Vic2NyaWJlJ1xuICBjb25zdCBjdGEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdoNScpXG4gIGN0YS5pZCA9ICdjdGEnXG4gIGN0YS5pbm5lckhUTUwgPSBqc29uWydTVUJTQ1JJQkUnXVsnQ1RBJ11cbiAgY29uc3Qgc3ViVHdpdHRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIHN1YlR3aXR0ZXIuaWQgPSAnc3ViVHdpdHRlcidcbiAgY29uc3Qgc3ViRW1haWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBzdWJFbWFpbC5pZCA9ICdzdWJFbWFpbCdcbiAgY29uc3Qgc3ViUnNzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgc3ViUnNzLmlkID0gJ3N1YlJzcydcbiAgc3Vic2NyaWJlLmFwcGVuZChjdGEsIHN1YlR3aXR0ZXIsIHN1YkVtYWlsLCBzdWJSc3MpXG4qL1xuXG4gIC8vIEluZm9cbiAgY29uc3QgaW5mbyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGluZm8uaWQgPSAnaW5mbydcbiAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgZGl2LmlubmVySFRNTCA9IGBCdWlsdCB3aXRoIEVtYWNzIE9yZy1tb2RlIOKAoiA8YSBocmVmPSdodHRwczovL2dpdGh1Yi5jb20vdGhld2VibWFzdGVycC90aGV3ZWJtYXN0ZXJwLmNvbSc+Q29kZTwvYT4gb3BlbiBzb3VyY2VkIOKAoiBSZWFkIHRoZSA8YSBocmVmPSdwcml2YWN5LXBvbGljeS5odG1sJz5Qcml2YWN5IFBvbGljeTwvYT4g4oCiIDxhIGhyZWY9XCJjb250YWN0Lmh0bWxcIj5Db250YWN0IG1lPC9hPmBcbiAgaW5mby5hcHBlbmRDaGlsZChkaXYpXG5cbiAgLy8gQm90dG9tXG4gIGNvbnN0IGJvdHRvbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gIGJvdHRvbS5pZCA9ICdib3R0b20nXG5cbiAgLy8gQXNzZW1ibGUgYW5kICdzcGl0JyB0aGUgZm9vdGVyXG4gIGNvbnN0IGZvb3RlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2Zvb3RlcicpXG4gIGZvb3Rlci5hcHBlbmQoc29jbWVkaWEsIC8qc3Vic2NyaWJlKi8gaW5mbywgYm90dG9tKVxuICByZXR1cm4gZm9vdGVyXG59XG5cbmV4cG9ydCBkZWZhdWx0IGZvb3RlckdlbmVyYXRvclxuIiwiY29uc3Qgc29jaWFsTWVkaWFCb3hHZW5lcmF0b3IgPSAoYXJyLCBpY29uc0Jhc2VQYXRoKSA9PiB7XG4gIC8vIGlucHV0IGZvcm1hdDogW3tsYWJlbDogZ2l0aHViLCBocmVmOiAnaHR0cHM6Ly93d3cuZ2l0aHViLmNvbScsIGljb246ICcuL2ljb25zL2ljb24ucG5nJyB9LCB7Li4ufV1cblxuICBjb25zdCBib3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICBib3guY2xhc3NOYW1lID0gJ3NvY01lZGlhQm94J1xuXG4gIGFyciA9IGFyci5tYXAoZW50cnkgPT4ge1xuICAgIGNvbnN0IHByb2ZpbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJylcbiAgICBwcm9maWxlLmNsYXNzTmFtZSA9ICdwcm9maWxlJ1xuICAgIHByb2ZpbGUuaHJlZiA9IGVudHJ5WydIUkVGJ11cblxuICAgIGNvbnN0IGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpJylcbiAgICBpY29uLnRpdGxlID0gZW50cnlbJ0xBQkVMJ11cblxuICAgIGNvbnN0IHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKVxuICAgIHJlcXVlc3Qub3BlbignR0VUJywgYCR7aWNvbnNCYXNlUGF0aH0vJHtlbnRyeVsnSUNPTiddfWAsIGZhbHNlKSAvLyBgZmFsc2VgIG1ha2VzIHRoZSByZXF1ZXN0IHN5bmNocm9ub3VzXG4gICAgcmVxdWVzdC5zZW5kKG51bGwpXG4gICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAyMDApIHtcbiAgICAgIGljb24uaW5uZXJIVE1MID0gcmVxdWVzdC5yZXNwb25zZVRleHRcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgJHtyZXF1ZXN0LnN0YXR1c30gZmV0Y2hpbmcgaWNvbnMuYClcbiAgICB9XG5cbiAgICBwcm9maWxlLmFwcGVuZENoaWxkKGljb24pXG4gICAgcmV0dXJuIHByb2ZpbGVcbiAgfSlcblxuICBib3guYXBwZW5kKC4uLmFycilcbiAgcmV0dXJuIGJveFxufVxuXG5leHBvcnQgZGVmYXVsdCBzb2NpYWxNZWRpYUJveEdlbmVyYXRvclxuIiwiY29uc3QgaWNvbkdlbmVyYXRvciA9IChsYWJlbCwgaW5uZXJIVE1MLCB0b29sdGlwKSA9PiB7XG4gIGNvbnN0IGljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpJylcbiAgaWNvbi5jbGFzc0xpc3QuYWRkKGAke2xhYmVsfS1pY29uYClcbiAgaWNvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgdG9vbHRpcClcbiAgaWNvbi5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgdHJ1ZSlcbiAgLy8gWW91IGNhbid0IHByb3Blcmx5IGdlbmVyYXRlIHN2ZyBlbGVtZW50IHdpdGggZG9jdW1lbnQuY3JlYXRlRWxlbWVudC4gWW91IGhhdmUgdG8gdXNlIGNyZWF0ZUVsZW1lbnROUywgYXMgZm9sbG93czpcbiAgY29uc3Qgc3ZnID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsICdzdmcnKVxuICAvLyBGb3IgbW9yZSBvbiB0aGUgdG9waWMsIHNlZSBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8yODczNDYyOC9ob3ctY2FuLWktc2V0LWFuLWF0dHJpYnV0ZS13aXRoLWNhc2Utc2Vuc2l0aXZlLW5hbWUtaW4tYS1qYXZhc2NyaXB0LWdlbmVyYXRlZC1lbC8yODczNDk1NFxuICBzdmcuY2xhc3NMaXN0LmFkZCgnZmVhdGhlcicsIGBmZWF0aGVyLSR7bGFiZWx9YClcbiAgc3ZnLnNldEF0dHJpYnV0ZSgnZmlsbCcsICdub25lJylcbiAgc3ZnLnNldEF0dHJpYnV0ZSgnc3Ryb2tlJywgJ2N1cnJlbnRDb2xvcicpXG4gIHN2Zy5zZXRBdHRyaWJ1dGUoJ3N0cm9rZS1saW5lY2FwJywgJ3JvdW5kJylcbiAgc3ZnLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLWxpbmVqb2luJywgJ3JvdW5kJylcbiAgc3ZnLnNldEF0dHJpYnV0ZSgnc3Ryb2tlLXdpZHRoJywgJzInKVxuICBzdmcuc2V0QXR0cmlidXRlKCd2aWV3Qm94JywgJzAgMCAyNCAyNCcpXG4gIHN2Zy5zZXRBdHRyaWJ1dGUoJ3htbG5zJywgJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJylcbiAgc3ZnLmlubmVySFRNTCA9IGlubmVySFRNTFxuICBpY29uLmFwcGVuZChzdmcpXG5cbiAgcmV0dXJuIGljb25cbn1cblxuY29uc3QgdGhlbWVDaGFuZ2VyQnRuID0gKHRvb2x0aXAsIG9uQ2xpY2spID0+IHtcbiAgLy9jb25zdCBjb25zdHJ1Y3Rpb25TaXRlcyA9IFsuLi5kb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKV1cblxuICBjb25zdCBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdidXR0b24nKVxuXG4gIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xpY2spXG5cbiAgY29uc3QgbW9vbkluSFRNTCA9XG4gICAgJzxwYXRoIGQ9XCJNMjEgMTIuNzlBOSA5IDAgMSAxIDExLjIxIDMgNyA3IDAgMCAwIDIxIDEyLjc5elwiLz4nXG4gIGNvbnN0IHN1bkluSFRNTCA9XG4gICAgJzxjaXJjbGUgY3g9XCIxMlwiIGN5PVwiMTJcIiByPVwiNVwiPjwvY2lyY2xlPjxsaW5lIHgxPVwiMTJcIiB4Mj1cIjEyXCIgeTE9XCIxXCIgeTI9XCIzXCI+PC9saW5lPjxsaW5lIHgxPVwiMTJcIiB4Mj1cIjEyXCIgeTE9XCIyMVwiIHkyPVwiMjNcIj48L2xpbmU+PGxpbmUgeDE9XCI0LjIyXCIgeDI9XCI1LjY0XCIgeTE9XCI0LjIyXCIgeTI9XCI1LjY0XCI+PC9saW5lPjxsaW5lIHgxPVwiMTguMzZcIiB4Mj1cIjE5Ljc4XCIgeTE9XCIxOC4zNlwiIHkyPVwiMTkuNzhcIj48L2xpbmU+PGxpbmUgeDE9XCIxXCIgeDI9XCIzXCIgeTE9XCIxMlwiIHkyPVwiMTJcIj48L2xpbmU+PGxpbmUgeDE9XCIyMVwiIHgyPVwiMjNcIiB5MT1cIjEyXCIgeTI9XCIxMlwiPjwvbGluZT48bGluZSB4MT1cIjQuMjJcIiB4Mj1cIjUuNjRcIiB5MT1cIjE5Ljc4XCIgeTI9XCIxOC4zNlwiPjwvbGluZT48bGluZSB4MT1cIjE4LjM2XCIgeDI9XCIxOS43OFwiIHkxPVwiNS42NFwiIHkyPVwiNC4yMlwiPjwvbGluZT4nXG4gIGNvbnN0IFttb29uSWNvbiwgc3VuSWNvbl0gPSBbXG4gICAgaWNvbkdlbmVyYXRvcignbW9vbicsIG1vb25JbkhUTUwsIHRvb2x0aXApLFxuICAgIGljb25HZW5lcmF0b3IoJ3N1bicsIHN1bkluSFRNTCwgdG9vbHRpcCksXG4gIF1cblxuICBjb25zdCBidG5UZXh0RWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJylcbiAgYnRuVGV4dEVsLmNsYXNzTGlzdC5hZGQoJ3NyLW9ubHknKVxuICBidG5UZXh0RWwudGV4dENvbnRlbnQgPSB0b29sdGlwXG5cbiAgYnV0dG9uLmFwcGVuZChtb29uSWNvbiwgc3VuSWNvbiwgYnRuVGV4dEVsKVxuXG4gIHJldHVybiBidXR0b25cbn1cblxuZXhwb3J0IGRlZmF1bHQgdGhlbWVDaGFuZ2VyQnRuXG4iLCJjb25zdCBtYXRvbW9Jbml0ID0gKCkgPT4ge1xuICAvLyBUT0RPOiBFbmFibGUgYW5kIGRlYnVnIHRoaXMgc2NyaXB0IGFmdGVyIHB1c2hlZCB0byBwcm9kdWN0aW9uXG4gIGNvbnNvbGUubG9nKCdoaSBmcm9tIG1hdG9tbyEnKVxuXG4gIHZhciBfcGFxID0gKHdpbmRvdy5fcGFxID0gd2luZG93Ll9wYXEgfHwgW10pXG4gIC8vIHRyYWNrZXIgbWV0aG9kcyBsaWtlIFwic2V0Q3VzdG9tRGltZW5zaW9uXCIgc2hvdWxkIGJlIGNhbGxlZCBiZWZvcmUgXCJ0cmFja1BhZ2VWaWV3XCJcbiAgX3BhcS5wdXNoKFsndHJhY2tQYWdlVmlldyddKVxuICBfcGFxLnB1c2goWydlbmFibGVMaW5rVHJhY2tpbmcnXSlcbiAgOyhmdW5jdGlvbigpIHtcbiAgICB2YXIgdSA9ICcvL21hdG9tby50aGV3ZWJtYXN0ZXJwLmNvbS8nXG4gICAgX3BhcS5wdXNoKFsnc2V0VHJhY2tlclVybCcsIHUgKyAnbWF0b21vLnBocCddKVxuICAgIF9wYXEucHVzaChbJ3NldFNpdGVJZCcsICcxJ10pXG4gICAgdmFyIGQgPSBkb2N1bWVudCxcbiAgICAgIGcgPSBkLmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxuICAgICAgcyA9IGQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpWzBdXG4gICAgZy5hc3luYyA9IHRydWVcbiAgICBnLnNyYyA9IHUgKyAnbWF0b21vLmpzJ1xuICAgIHMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZywgcylcbiAgfSkoKVxufVxuXG5leHBvcnQgZGVmYXVsdCBtYXRvbW9Jbml0XG4iLCJmdW5jdGlvbiB4bWwyanNvbih4bWwpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb2JqID0ge31cbiAgICBpZiAoeG1sLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeG1sLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBpdGVtID0geG1sLmNoaWxkcmVuLml0ZW0oaSlcbiAgICAgICAgdmFyIG5vZGVOYW1lID0gaXRlbS5ub2RlTmFtZVxuXG4gICAgICAgIGlmICh0eXBlb2Ygb2JqW25vZGVOYW1lXSA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIG9ialtub2RlTmFtZV0gPSB4bWwyanNvbihpdGVtKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0eXBlb2Ygb2JqW25vZGVOYW1lXS5wdXNoID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB2YXIgb2xkID0gb2JqW25vZGVOYW1lXVxuXG4gICAgICAgICAgICBvYmpbbm9kZU5hbWVdID0gW11cbiAgICAgICAgICAgIG9ialtub2RlTmFtZV0ucHVzaChvbGQpXG4gICAgICAgICAgfVxuICAgICAgICAgIG9ialtub2RlTmFtZV0ucHVzaCh4bWwyanNvbihpdGVtKSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBvYmogPSB4bWwudGV4dENvbnRlbnRcbiAgICB9XG4gICAgcmV0dXJuIG9ialxuICB9IGNhdGNoIChlKSB7XG4gICAgY29uc29sZS5sb2coZS5tZXNzYWdlKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHhtbDJqc29uXG4iLCIvLyBUaGUgbW9kdWxlIGNhY2hlXG52YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG5cbi8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG5mdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuXHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcblx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0cmV0dXJuIGNhY2hlZE1vZHVsZS5leHBvcnRzO1xuXHR9XG5cdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG5cdHZhciBtb2R1bGUgPSBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX19bbW9kdWxlSWRdID0ge1xuXHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcblx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuXHRcdGV4cG9ydHM6IHt9XG5cdH07XG5cblx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG5cdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdKG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZGVmaW5lIGdldHRlciBmdW5jdGlvbnMgZm9yIGhhcm1vbnkgZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcblx0Zm9yKHZhciBrZXkgaW4gZGVmaW5pdGlvbikge1xuXHRcdGlmKF9fd2VicGFja19yZXF1aXJlX18ubyhkZWZpbml0aW9uLCBrZXkpICYmICFfX3dlYnBhY2tfcmVxdWlyZV9fLm8oZXhwb3J0cywga2V5KSkge1xuXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcblx0XHR9XG5cdH1cbn07IiwiX193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuXHRpZiAodHlwZW9mIGdsb2JhbFRoaXMgPT09ICdvYmplY3QnKSByZXR1cm4gZ2xvYmFsVGhpcztcblx0dHJ5IHtcblx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdGlmICh0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JykgcmV0dXJuIHdpbmRvdztcblx0fVxufSkoKTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSAob2JqLCBwcm9wKSA9PiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCkpIiwiLy8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yID0gKGV4cG9ydHMpID0+IHtcblx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbn07IiwidmFyIHNjcmlwdFVybDtcbmlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmcuaW1wb3J0U2NyaXB0cykgc2NyaXB0VXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmxvY2F0aW9uICsgXCJcIjtcbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5kb2N1bWVudDtcbmlmICghc2NyaXB0VXJsICYmIGRvY3VtZW50KSB7XG5cdGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KVxuXHRcdHNjcmlwdFVybCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjXG5cdGlmICghc2NyaXB0VXJsKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRpZihzY3JpcHRzLmxlbmd0aCkgc2NyaXB0VXJsID0gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdLnNyY1xuXHR9XG59XG4vLyBXaGVuIHN1cHBvcnRpbmcgYnJvd3NlcnMgd2hlcmUgYW4gYXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCB5b3UgbXVzdCBzcGVjaWZ5IGFuIG91dHB1dC5wdWJsaWNQYXRoIG1hbnVhbGx5IHZpYSBjb25maWd1cmF0aW9uXG4vLyBvciBwYXNzIGFuIGVtcHR5IHN0cmluZyAoXCJcIikgYW5kIHNldCB0aGUgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gdmFyaWFibGUgZnJvbSB5b3VyIGNvZGUgdG8gdXNlIHlvdXIgb3duIGxvZ2ljLlxuaWYgKCFzY3JpcHRVcmwpIHRocm93IG5ldyBFcnJvcihcIkF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuc2NyaXB0VXJsID0gc2NyaXB0VXJsLnJlcGxhY2UoLyMuKiQvLCBcIlwiKS5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKS5yZXBsYWNlKC9cXC9bXlxcL10rJC8sIFwiL1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18ucCA9IHNjcmlwdFVybCArIFwiLi4vXCI7IiwiaW1wb3J0IG1hdG9tb0luaXQgZnJvbSAnLi9tYXRvbW9Jbml0J1xuXG5pbXBvcnQgYW55IGZyb20gJy4vYWN0aW9ucy9hbnknXG5pbXBvcnQgaW5kZXhQYWdlIGZyb20gJy4vYWN0aW9ucy9pbmRleFBhZ2UnXG5pbXBvcnQgYWJvdXRQYWdlIGZyb20gJy4vYWN0aW9ucy9hYm91dFBhZ2UnXG5pbXBvcnQgY29udGFjdFBhZ2UgZnJvbSAnLi9hY3Rpb25zL2NvbnRhY3RQYWdlJ1xuaW1wb3J0IGJsb2cgZnJvbSAnLi9hY3Rpb25zL2Jsb2cnXG5pbXBvcnQgYmxvZ1BhZ2UgZnJvbSAnLi9hY3Rpb25zL2Jsb2dQYWdlJ1xuaW1wb3J0IGJsb2dBcnRpY2xlIGZyb20gJy4vYWN0aW9ucy9ibG9nQXJ0aWNsZSdcblxuY29uc3QgQ09ORklHID0ge1xuICBkZWZhdWx0VGhlbWU6ICdkYXJrJyxcbiAgdGhlbWVBdHRyaWJ1dGU6ICdkYXRhLXRoZW1lJyxcbiAgaWNvbnNCYXNlUGF0aDogJy9jc3MvaWNvbnMnLFxufVxuXG5jbGFzcyBSdWxlIHtcbiAgY29uc3RydWN0b3IobmFtZSwgY29uZGl0aW9uLCBhY3Rpb24sIGlkKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMuY29uZGl0aW9uID0gY29uZGl0aW9uXG4gICAgdGhpcy5hY3Rpb24gPSBhY3Rpb25cbiAgICB0aGlzLmlkID0gaWRcbiAgfVxuICBzdGF0aWMgZ2VuQ29uZGl0KGFycikge1xuICAgIHJldHVybiBwYXRoID0+IHtcbiAgICAgIC8vIE5PVEU6IFNvbWV0aW1lcywgaWYgdGhlIGxpbmsgaGFzIGEgZG91Ymxlc2hsYXNoLCBpdCBmYWlscyB0aGVzZSB0ZXN0cyBhbmQgdGhlXG4gICAgICAvLyBzaXRlIGJyZWFrcyEgSSBkaWRuJ3QgcmVzb2x2ZSB0aGlzIGluIHRoZSBmcm9udC1lbmQgYmVjYXVzZSBldmVuIGlmIGkgZGlkIHNvLFxuICAgICAgLy8gaXQgd291bGRuJ3Qgc29sdmUgdGhlIHByb2JsZW0gaW4gaXRzIHJvb3Q6IFdoeSB0aGlzIHdob2xlIHRoaW5nIGRlcGVuZHMgb24gdGhlIHVybD9cbiAgICAgIHJldHVybiBhcnIuc29tZShzdHIgPT4ge1xuICAgICAgICAvKlxuICAgICAgICBjb25zb2xlLmxvZyhgQ29tcGFyaW5nOiAnJHtzdHJ9JyB3aXRoICcke3BhdGh9J2ApXG4gICAgICAgIGNvbnNvbGUubG9nKFxuICAgICAgICAgIGA9PiAke3N0ciA9PT0gcGF0aH0gfHxcbiAgICAgICAgICAgICR7c3RyID09PSBkZWNvZGVVUklDb21wb25lbnQocGF0aCl9IHx8XG4gICAgICAgICAgICAke3N0ciA9PT0gZW5jb2RlVVJJQ29tcG9uZW50KHBhdGgpfWBcbiAgICAgICAgKSovXG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgc3RyID09PSBwYXRoIHx8XG4gICAgICAgICAgc3RyID09PSBkZWNvZGVVUklDb21wb25lbnQocGF0aCkgfHxcbiAgICAgICAgICBzdHIgPT09IGVuY29kZVVSSUNvbXBvbmVudChwYXRoKVxuICAgICAgICApXG4gICAgICB9KVxuICAgIH1cbiAgfVxufVxuXG5jb25zdCBydWxlcyA9IFtcbiAgbmV3IFJ1bGUoJ2FueScsICgpID0+IHRydWUsIGFueSksXG4gIG5ldyBSdWxlKFxuICAgICdpbmRleFBhZ2UnLFxuICAgIFJ1bGUuZ2VuQ29uZGl0KFsnLycsICcvaW5kZXgnLCAnL2luZGV4Lmh0bWwnLCAnaW5kZXgnXSksXG4gICAgaW5kZXhQYWdlLFxuICAgICdpbmRleCdcbiAgKSxcbiAgbmV3IFJ1bGUoXG4gICAgJ2Fib3V0UGFnZScsXG4gICAgUnVsZS5nZW5Db25kaXQoWycvYWJvdXQuaHRtbCcsICcvYWJvdXQnLCAnYWJvdXQnXSksXG4gICAgYWJvdXRQYWdlLFxuICAgICdhYm91dCdcbiAgKSxcbiAgbmV3IFJ1bGUoXG4gICAgJ2NvbnRhY3RQYWdlJyxcbiAgICBSdWxlLmdlbkNvbmRpdChbJy9jb250YWN0Lmh0bWwnLCAnL2NvbnRhY3QnLCAnY29udGFjdCddKSxcbiAgICBjb250YWN0UGFnZSxcbiAgICAnY29udGFjdCdcbiAgKSxcbiAgbmV3IFJ1bGUoJ2Jsb2cnLCBwYXRoID0+IHBhdGguaW5jbHVkZXMoJ2Jsb2cnKSwgYmxvZyksXG4gIG5ldyBSdWxlKFxuICAgICdibG9nUGFnZScsXG4gICAgUnVsZS5nZW5Db25kaXQoWycvYmxvZy5odG1sJywgJy9ibG9nJywgJ2Jsb2cnXSksXG4gICAgYmxvZ1BhZ2UsXG4gICAgJ2Jsb2cnXG4gICksXG4gIG5ldyBSdWxlKFxuICAgICdhcnRpY2xlJyxcbiAgICBwYXRoID0+IHtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIHBhdGguaW5jbHVkZXMoJ2Jsb2cnKSAmJlxuICAgICAgICAhUnVsZS5nZW5Db25kaXQoWycvYmxvZy5odG1sJywgJy9ibG9nJywgJ2Jsb2cnXSkocGF0aClcbiAgICAgIClcbiAgICB9LFxuICAgIGJsb2dBcnRpY2xlLFxuICAgICdhcnRpY2xlJ1xuICApLFxuXVxuXG5jb25zdCBtYWluID0gKGV2ZW50LCBjb25maWcpID0+IHtcbiAgY29uc3Qgc3RhdHVzID0gZXZlbnQudHlwZVxuICBjb25zdCBwYXRobmFtZSA9IHdpbmRvdy5sb2NhdGlvbi5wYXRobmFtZVxuICBjb25zdCBtYXRjaGluZyA9IHJ1bGVzLmZpbHRlcihlbnRyeSA9PiB7XG4gICAgLy8gY29uc29sZS5sb2coZW50cnkuY29uZGl0aW9uKVxuICAgIHJldHVybiBlbnRyeS5jb25kaXRpb24ocGF0aG5hbWUpXG4gIH0pXG4gIGNvbnN0IHN0YXJ0ZXJQYWNrID0ge1xuICAgIGNvbmZpZzogY29uZmlnLFxuICAgIHN0YXR1czogc3RhdHVzLFxuICAgIERPTUNvbnRlbnRMb2FkZWQ6IHN0YXR1cyA9PT0gJ0RPTUNvbnRlbnRMb2FkZWQnLFxuICAgIGxvYWQ6IHN0YXR1cyA9PT0gJ2xvYWQnLFxuICAgIGJlZm9yZXVubG9hZDogc3RhdHVzID09PSAnYmVmb3JldW5sb2FkJyxcbiAgICBodG1sOiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQsXG4gICAgaGVhZDogZG9jdW1lbnQuaGVhZCxcbiAgICBib2R5OiBkb2N1bWVudC5ib2R5LFxuICAgIHByZWFtYmxlOiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgncHJlYW1ibGUnKSxcbiAgICB0b3BuYXY6IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCd0b3BuYXYnKSxcbiAgICBjb250ZW50OiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY29udGVudCcpLFxuICAgIHBvc3RhbWJsZTogZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3Bvc3RhbWJsZScpLFxuICAgIGZvb3RlcjogZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2Zvb3RlcicpWzBdLFxuICAgIGxvZzogY29uc29sZS5sb2csXG4gICAgZXJyOiBjb25zb2xlLmVycm9yLFxuICAgIG1hdGNoZWRSdWxlc0xpc3Q6IG1hdGNoaW5nLFxuICAgIHNldEFjdGl2ZU5hdkVudHI6IGNsYXNzTmFtZSA9PiB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKGNsYXNzTmFtZSlbMF1cbiAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoJ2RhdGEtY3VycmVudCcsICcnKVxuICAgIH0sXG4gICAgb3BlbkltYWdlT246IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHVybCA9IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoJ3NyYycpXG4gICAgICB3aW5kb3cub3Blbih1cmwsICdfYmxhbmsnKS5mb2N1cygpXG4gICAgfSxcbiAgfVxuICBtYXRjaGluZy5mb3JFYWNoKGVudHJ5ID0+IHtcbiAgICBpZiAoZW50cnkubmFtZSA9PT0gJ2FueScpIHJldHVyblxuICAgIHN0YXJ0ZXJQYWNrLmVudHJ5TmFtZSA9IGVudHJ5Lm5hbWUgfHwgbnVsbFxuICAgIGVudHJ5LmFjdGlvbihzdGFydGVyUGFjaylcbiAgfSlcbiAgLy8gJ2FueScgc2hvdWxkIGJlIGNhbGxlZCBsYXN0XG4gIG1hdGNoaW5nLmZvckVhY2goZW50cnkgPT4ge1xuICAgIGlmIChlbnRyeS5uYW1lID09PSAnYW55Jykge1xuICAgICAgc3RhcnRlclBhY2suZW50cnlOYW1lID0gJ2FueSdcbiAgICAgIGVudHJ5LmFjdGlvbihzdGFydGVyUGFjaylcbiAgICB9XG4gIH0pXG5cbiAgLy8gSW5pdGlhbGl6ZSBtYXRvbW9cbiAgbWF0b21vSW5pdCgpXG59XG5cbmNvbnN0IG1haW5DYWxsZXIgPSBldmVudCA9PiB7XG4gIG1haW4oZXZlbnQsIENPTkZJRylcbn1cbndpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgbWFpbkNhbGxlcikgLy8gRE9NIGxvYWRlZFxud2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBtYWluQ2FsbGVyKSAvLyBET00gKyBzdGF0aWMgbG9hZGVkXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgbWFpbkNhbGxlcikgLy8gdW5sb2FkZWQgKHByZXNzaW5nIGJhY2ssIHZpc2l0aW5nIGxpbmsgLi4uKVxuIiwiZXhwb3J0IGRlZmF1bHQgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gKyBcImNzcy9zdHlsZS5taW4uY3NzXCI7Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9